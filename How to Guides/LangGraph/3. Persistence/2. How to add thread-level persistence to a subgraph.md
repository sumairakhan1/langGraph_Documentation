# ğŸ§µ How to Add Thread-Level Persistence to a Subgraph in LangGraph  

## ğŸ“Œ **Introduction**  
Thread-level persistence is crucial for maintaining execution state in LangGraph, especially when working with **subgraphs**. In this guide, you'll learn how to integrate persistence into a subgraph by using **memory-based checkpointing**.  

This guide covers:  
âœ… What **thread-level persistence** means  
âœ… How to set up **LangGraph** for persistence  
âœ… A **real-world example** where this concept is useful  
âœ… **Step-by-step** code explanation  

---

## ğŸ¯ **What is Thread-Level Persistence?**  
Thread-level persistence ensures that the execution state of a **graph and its subgraphs** is stored and retrievable even after execution. This is useful for:  
âœ”ï¸ Long-running processes that may be interrupted  
âœ”ï¸ Saving intermediate results  
âœ”ï¸ Debugging and performance improvements  

---

## ğŸŒ **Real-World Example: AI Chatbot Memory**  
Imagine you are building a chatbot where users can ask **follow-up questions**. Without persistence, each response would be **stateless**, meaning the bot forgets previous messages. **Thread-level persistence** allows the bot to remember past interactions, even when processing occurs in **separate threads**.  

---

## ğŸ›  **Setup: Install Required Packages**  
First, install the `langgraph` package:  

```python
%%capture --no-stderr
%pip install -U langgraph
```

You also need **LangSmith** for debugging and monitoring LangGraph apps.

---

## ğŸ“œ **Step 1: Define the Subgraph**  
A **subgraph** is a smaller, reusable component inside a larger **parent graph**. Below, we define a subgraph that:  
1ï¸âƒ£ Accepts an input value `"foo"`  
2ï¸âƒ£ Computes `"bar"` based on `"foo"`  
3ï¸âƒ£ Returns the modified state  

### ğŸ“ **Code Implementation**  

```python
from langgraph.graph import START, StateGraph
from langgraph.checkpoint.memory import MemorySaver
from typing import TypedDict

# ğŸ¯ Define the state format for the subgraph
class SubgraphState(TypedDict):
    foo: str  # Shared with parent graph
    bar: str  # Used only within the subgraph

# ğŸ¯ Define nodes in the subgraph
def subgraph_node_1(state: SubgraphState):
    return {"bar": "bar"}  # Adds 'bar' to the state

def subgraph_node_2(state: SubgraphState):
    return {"foo": state["foo"] + state["bar"]}  # Modifies 'foo' using 'bar'

# ğŸ¯ Create the subgraph
subgraph_builder = StateGraph(SubgraphState)
subgraph_builder.add_node(subgraph_node_1)
subgraph_builder.add_node(subgraph_node_2)
subgraph_builder.add_edge(START, subgraph_node_1)  # Start -> Node 1
subgraph_builder.add_edge(subgraph_node_1, subgraph_node_2)  # Node 1 -> Node 2

subgraph = subgraph_builder.compile()  # Compile the subgraph
```

### ğŸ” **Explanation**  
ğŸ”¹ **`TypedDict`** defines the expected structure of the subgraph state  
ğŸ”¹ **Nodes (`subgraph_node_1` & `subgraph_node_2`)** modify the state step by step  
ğŸ”¹ **Edges define execution order** (first `subgraph_node_1`, then `subgraph_node_2`)  
ğŸ”¹ **`compile()`** converts the structure into an executable subgraph  

---

## ğŸ“œ **Step 2: Define the Parent Graph**  
The **parent graph**:  
âœ… Calls `node_1` first  
âœ… Then runs the subgraph as `node_2`  

### ğŸ“ **Code Implementation**  

```python
# ğŸ¯ Define the state format for the parent graph
class State(TypedDict):
    foo: str  # Shared with subgraph

# ğŸ¯ Define the parent graph node
def node_1(state: State):
    return {"foo": "hi! " + state["foo"]}  # Modifies 'foo'

# ğŸ¯ Create the parent graph
builder = StateGraph(State)
builder.add_node("node_1", node_1)  
builder.add_node("node_2", subgraph)  # Adds the subgraph as a node

builder.add_edge(START, "node_1")  # Start -> Node 1
builder.add_edge("node_1", "node_2")  # Node 1 -> Subgraph (Node 2)
```

### ğŸ” **Explanation**  
ğŸ”¹ **`node_1`** appends `"hi! "` to `foo`  
ğŸ”¹ **`node_2` (subgraph)** modifies `foo` further  
ğŸ”¹ **Graph execution order:** `node_1 â†’ subgraph`  

---

## ğŸ“œ **Step 3: Add Persistence Using Checkpointing**  
To persist execution state across threads, use **`MemorySaver`**.  

### ğŸ“ **Code Implementation**  

```python
checkpointer = MemorySaver()  # Creates an in-memory checkpointer

# ğŸ¯ Compile the graph with persistence
graph = builder.compile(checkpointer=checkpointer)
```

### ğŸ” **Explanation**  
ğŸ”¹ **`MemorySaver`** stores execution history in memory  
ğŸ”¹ **Passing `checkpointer` ensures thread-level persistence**  

---

## ğŸ“œ **Step 4: Run the Graph and Verify Persistence**  
Now, let's **execute** the graph and inspect the **state persistence**.  

### ğŸ“ **Code Implementation**  

```python
config = {"configurable": {"thread_id": "1"}}  # Unique thread ID

# ğŸ¯ Stream execution and print state at each step
for _, chunk in graph.stream({"foo": "foo"}, config, subgraphs=True):
    print(chunk)
```

### ğŸ” **Expected Output**  
```
{'node_1': {'foo': 'hi! foo'}}
{'subgraph_node_1': {'bar': 'bar'}}
{'subgraph_node_2': {'foo': 'hi! foobar'}}
{'node_2': {'foo': 'hi! foobar'}}
```
### ğŸ” **Explanation**  
1ï¸âƒ£ **`node_1` modifies `foo` â†’ `"hi! foo"`**  
2ï¸âƒ£ **`subgraph_node_1` adds `"bar"`**  
3ï¸âƒ£ **`subgraph_node_2` appends `"bar"` to `"foo"` â†’ `"hi! foobar"`**  
4ï¸âƒ£ **Final result is stored in `foo`**  

---

## ğŸ“œ **Step 5: Retrieve Stored State**  
### ğŸ“ **Code Implementation**  

```python
# ğŸ¯ Retrieve the final state of the parent graph
graph.get_state(config).values
```
### ğŸ” **Expected Output**  
```python
{'foo': 'hi! foobar'}
```
---

## ğŸ“œ **Step 6: Retrieve Subgraph State**  
Since subgraphs use their own configurations, we need to **fetch the subgraph state separately**.  

### ğŸ“ **Code Implementation**  

```python
# ğŸ¯ Find the last state before entering the subgraph
state_with_subgraph = [
    s for s in graph.get_state_history(config) if s.next == ("node_2",)
][0]

# ğŸ¯ Extract the subgraph config
subgraph_config = state_with_subgraph.tasks[0].state

# ğŸ¯ Retrieve the subgraph state
graph.get_state(subgraph_config).values
```
### ğŸ” **Expected Output**  
```python
{'foo': 'hi! foobar', 'bar': 'bar'}
```
---

## ğŸš€ **Final Thoughts**  
âœ… **Thread-level persistence** ensures that LangGraph can resume execution from where it stopped.  
âœ… **Subgraphs inherit persistence automatically from the parent graph** (no need to define checkpointer again).  
âœ… **This technique is useful for AI assistants, workflows, and long-running LLM applications.**  

Would you like a **step-by-step video demo** or more **advanced examples**? Let me know! ğŸš€