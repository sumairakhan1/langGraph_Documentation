# 1. 1. How to run an agent in the background

# **Understanding Background Runs in Programming** üåê

Background runs are processes or tasks that are executed separately from the main flow of a program or system. These tasks run in the background while the main application continues to work, ensuring the program remains responsive. This concept is widely used in areas such as web services, API calls, and long-running tasks.

---

## **What Are Background Runs?** üíª

Background runs are essentially tasks that run independently of the main execution thread. They are often used to handle operations that would take too long to complete in the foreground. For instance, they can be used for sending emails, processing large amounts of data, or handling complex calculations.

**Real-World Example**: Think of background runs like receiving a notification on your phone. You can continue browsing while the notification is being fetched in the background.

---

## **How to Kick Off Background Runs** üöÄ

To set up a background run, you'll need to create a client and thread. This is essential to initialize the environment that will allow you to send requests to perform background operations.

### Example Setup Code (Python):

```python
from langgraph_sdk import get_client

client = get_client(url=<DEPLOYMENT_URL>)
# Using the graph deployed with the name "agent"
assistant_id = "agent"
# create thread
thread = await client.threads.create()
print(thread)
```

### Explanation:
- **Client**: Represents the connection to the system where the background task will be executed.
- **Thread**: A context or container where the tasks (runs) will be carried out.
- **Assistant ID**: Refers to a specific assistant or model that's used to handle the tasks.

---

## **Checking Existing Runs** üîç

Once you have set up your client and thread, you can list the current runs on the thread. Initially, there won‚Äôt be any, as the thread is empty.

### Example Code to List Runs:

```python
runs = await client.runs.list(thread["thread_id"])
print(runs)
```

### Output:

```json
[]
```

Here, we see an empty list, as there are no runs started yet on this thread.

---

## **Starting a Background Run** ‚ö°

Now, let's kick off a background run. This is where you initiate the task that will run in the background.

### Example Code to Start a Run:

```python
input = {"messages": [{"role": "user", "content": "what's the weather in sf"}]}
run = await client.runs.create(thread["thread_id"], assistant_id, input=input)
```

### Explanation:
- **Input**: This is the data we send to the assistant, such as a user's question about the weather.
- **Create Run**: This starts the background task with the provided input, which will be processed asynchronously.

---

## **Checking Run Status** ‚è≥

You can periodically check the status of the background run to see if it's still pending or has completed.

### Example Code to Check Status:

```python
print(await client.runs.get(thread["thread_id"], run["run_id"]))
```

### Output Example:

```json
{
    "run_id": "1ef6a5f8-bd86-6763-bbd6-bff042db7b1b",
    "status": "pending"
}
```

At this point, the status is still pending, meaning the task is still being processed in the background.

---

## **Waiting for Completion and Finalizing** ‚úÖ

Once the background run is started, you can join it (wait for it to complete) and then check the final status.

### Example Code to Wait for Completion:

```python
await client.runs.join(thread["thread_id"], run["run_id"])
print(await client.runs.get(thread["thread_id"], run["run_id"]))
```

### Output Example (After Run Completion):

```json
{
    "run_id": "1ef6a5f8-bd86-6763-bbd6-bff042db7b1b",
    "status": "success"
}
```

Once the run completes, the status changes to **success**, indicating the task has been successfully executed.

---

## **Final Results** üéØ

After the background run is completed, you can retrieve the final results of the task. This could include data or output generated by the background operation.

### Example Code to Get Final Results:

```python
final_result = await client.threads.get_state(thread["thread_id"])
print(final_result)
```

### Output Example:

```json
{
    "values": {
        "messages": [
            {
                "content": "what's the weather in sf",
                "type": "human"
            },
            {
                "content": "The current weather in San Francisco is 70¬∞F with partly cloudy skies.",
                "type": "ai"
            }
        ]
    }
}
```

The final results show the weather information for San Francisco, retrieved as part of the background task.

---

## **Real-World Use Case** üåç

Imagine you are building a weather chatbot that answers user queries about the weather in various cities. Instead of waiting for the chatbot to fetch weather data from an API every time, you can use background runs to process the API request in the background. This allows the bot to handle other user interactions while the weather data is being fetched.

**How it helps**:
- **Efficiency**: The bot can handle multiple requests simultaneously without delays.
- **User Experience**: Users get quick responses without waiting for long-running tasks to finish.

---

## **Conclusion** üéâ

Background runs are crucial in modern programming, especially when dealing with long-running tasks or multiple simultaneous operations. They allow the main application to remain responsive, enhancing the user experience. By following the setup, execution, and status-checking steps outlined above, you can implement background runs in your projects efficiently.