# 4. How to Create Stateless Runs ğŸŒ

In LangGraph Cloud, when you run a graph, you typically need a **thread_id** to keep track of the state of the run. This allows you to track previous interactions and ensure that the state persists over time. However, sometimes you may not need to keep track of the state, which is where **stateless runs** come in.

Stateless runs are useful for cases where you donâ€™t need to store any history or context of prior runs. You can create and run tasks without worrying about the state being persisted, making the process more lightweight and efficient.

### What are Stateless Runs? ğŸ¤”

A **stateless run** is a type of run where no state is stored between executions. Unlike typical graph runs, which require tracking the state of the graphâ€™s progress, stateless runs are executed without keeping track of previous information. This is especially useful when you donâ€™t need to save or reuse data from earlier executions.

For example, if youâ€™re building a chatbot that doesn't need to remember past conversations and only processes a single interaction at a time, you can use a stateless run to handle the chat.

### When to Use Stateless Runs? ğŸ¯

You should use stateless runs when:
- **No persistence** is required between runs.
- You donâ€™t need to track previous inputs and outputs.
- You want a quick, lightweight execution for a one-time task.
- Youâ€™re handling tasks that don't require previous context, such as simple responses or standalone actions.

### Setting Up the Client ğŸ› ï¸

To begin using stateless runs, first, set up your **client** with the appropriate configuration. Youâ€™ll need to initialize the LangGraph SDK and create a thread for processing.

```python
from langgraph_sdk import get_client

client = get_client(url=<DEPLOYMENT_URL>)
# Using the graph deployed with the name "agent"
assistant_id = "agent"
# Create thread
thread = await client.threads.create()
```

This creates the initial setup with a connection to LangGraph Cloud.

### Stateless Streaming ğŸ“¡

When working with stateless runs, you can stream results just like you would with stateful runs, but without passing a **thread_id**. By setting the `thread_id` to `None`, you specify that you are making a stateless run.

Hereâ€™s an example of how to stream results from a stateless run:

```python
input = {
    "messages": [
        {"role": "user", "content": "Hello! My name is Bagatur and I am 26 years old."}
    ]
}

# Stream results without passing a thread_id
async for chunk in client.runs.stream(
    None,  # No thread_id for stateless run
    assistant_id,
    input=input,
    stream_mode="updates",
):
    if chunk.data and "run_id" not in chunk.data:
        print(chunk.data)
```

#### Output:

```json
{
    'agent': {
        'messages': [
            {'content': "Hello Bagatur! It's nice to meet you. Thank you for introducing yourself and sharing your age. Is there anything specific you'd like to know or discuss? I'm here to help with any questions or topics you're interested in.", 'type': 'ai'}
        ]
    }
}
```

In this example, the stateless run processes the input message without storing any previous interactions.

### Waiting for Stateless Results â³

If you don't want to stream the results, you can also wait for the stateless run to complete and get the result all at once using the `.wait()` function.

Hereâ€™s how you can wait for the result of a stateless run:

```python
stateless_run_result = await client.runs.wait(
    None,  # No thread_id for stateless run
    assistant_id,
    input=input,
)
print(stateless_run_result)
```

#### Output:

```json
{
    'messages': [
        {
            'content': 'Hello! My name is Bagatur and I am 26 years old.',
            'type': 'human'
        },
        {
            'content': "Hello Bagatur! It's nice to meet you. Thank you for introducing yourself and sharing your age. Is there anything specific you'd like to know or discuss? I'm here to help with any questions or topics you'd like to explore.",
            'type': 'ai'
        }
    ]
}
```

In this example, you get the output for the input message, and the system processes it without needing to track previous interactions.

### Real-World Use Case: One-Time Queries ğŸ¤–

Letâ€™s say youâ€™re developing a customer support chatbot for a website. A user might ask the bot a simple, one-time question like **â€œWhat are your office hours?â€**. In this case, the bot doesnâ€™t need to remember any previous questions, and the interaction is isolated.

- **Stateless Run Example**: The bot processes the userâ€™s query and gives a direct response like **â€œOur office hours are from 9 AM to 5 PM, Monday through Friday.â€**
- **No Context Needed**: Once the user gets their answer, thereâ€™s no need to track the conversation history or store any data. A stateless run handles this perfectly, as the interaction doesnâ€™t require persistence.

### Advantages of Stateless Runs ğŸŒŸ

- **No Persistence**: Since thereâ€™s no state being saved, stateless runs are lightweight and faster.
- **Simplicity**: Perfect for simple, one-time tasks where context is not needed.
- **Cost-Efficient**: Stateless runs avoid using resources to store unnecessary state, saving on API charges.

### Key Takeaways ğŸ“š

- **Stateless runs** are useful for tasks where you donâ€™t need to track or store any prior interactions.
- To execute stateless runs, simply omit the `thread_id` by passing `None`.
- Stateless runs can be used for quick tasks like responding to one-time queries or sending simple updates without needing historical context.
- Stateless runs are more lightweight, cost-efficient, and suitable for isolated, independent tasks.

### Conclusion ğŸ¯

Stateless runs in LangGraph Cloud provide a straightforward way to execute tasks without the need for persistent state. They are perfect for handling one-off tasks, simple queries, or processes that donâ€™t require tracking previous actions. By omitting the thread context, you ensure the system remains lightweight and efficient. Whether you're building a customer support bot or a quick notification system, stateless runs are an excellent tool for managing tasks that don't need to persist between executions.