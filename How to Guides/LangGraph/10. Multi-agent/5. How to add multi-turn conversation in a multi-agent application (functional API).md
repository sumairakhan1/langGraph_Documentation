# 5. How to add multi-turn conversation in a multi-agent application (functional API)


# **How to Add Multi-Turn Conversation in a Multi-Agent Application** üó£Ô∏èü§ñ

In this guide, we will walk through building a multi-turn conversational system in a multi-agent environment using a **functional API**. Multi-turn conversations involve back-and-forth interaction between a user and one or more agents (chatbots, virtual assistants, etc.). The purpose of this system is to enable a conversation that doesn't end after one exchange but continues with multiple steps, allowing the user to interact with different agents as needed.

This tutorial includes the following steps:

- **Creating agents** that will handle different conversation aspects.
- **Defining tasks** to trigger those agents.
- **Implementing workflows** to coordinate agents' responses and handle user input.
- **Adding a mechanism** for agent handoff, allowing one agent to transfer the conversation to another.

Let‚Äôs break it down into easy steps with code examples and detailed explanations.

---

## üßë‚Äçüíª **Understanding the Workflow of a Multi-Turn System**

### 1. **Tools and Setup** üõ†Ô∏è
In our multi-agent application, we will be using **Langgraph** and **Langchain** libraries. These libraries allow us to define agents, manage workflows, and handle interrupts (such as user inputs).

**What is a tool?**  
A **tool** in our system is a function that is used to interact with the agent. For example, when the user asks about hotels, we‚Äôll use a tool to send the user‚Äôs request to a travel advisor agent.

### 2. **Define a Tool for Agent Handoff** üîÑ
To allow one agent to transfer the conversation to another (a handoff), we define a tool.

```python
from langchain_core.tools import tool

@tool(return_direct=True)
def transfer_to_hotel_advisor():
    """Ask hotel advisor agent for help."""
    return "Successfully transferred to hotel advisor"
```

#### **Explanation of the code:**
- **@tool**: This decorator marks the function as a tool, which means this tool can be invoked by the agents.
- **return_direct=True**: This indicates the tool returns a direct response that is immediately used by the agent.
- **transfer_to_hotel_advisor()**: This function represents a "handoff" action. When invoked, it tells the system that the conversation should now be handled by the hotel advisor agent.

---

## ü§ñ **Define an Agent**

An agent is responsible for responding to a user‚Äôs query. In our case, we are defining a **travel advisor agent**.

```python
from langgraph.prebuilt import create_react_agent

travel_advisor_tools = [transfer_to_hotel_advisor, ...]
travel_advisor = create_react_agent(model, travel_advisor_tools)
```

#### **Explanation of the code:**
- **travel_advisor_tools**: This list contains the tools (like `transfer_to_hotel_advisor`) that our agent can use. These tools will enable the agent to transfer the conversation or perform other tasks.
- **create_react_agent()**: This function is used to create the agent. It takes the model (language model used by the agent) and the tools the agent can access.
- **travel_advisor**: The variable holds the created agent that we‚Äôll use to interact with the user.

---

## üéØ **Define a Task for Calling the Agent**

A **task** is an action that the system performs, in this case, calling the travel advisor agent.

```python
@task
def call_travel_advisor(messages):
    response = travel_advisor.invoke({"messages": messages})
    return response["messages"]
```

#### **Explanation of the code:**
- **@task**: This decorator defines the function as a task that can be invoked as part of the workflow.
- **call_travel_advisor()**: This function will invoke the `travel_advisor` agent. It takes `messages` (conversation history) as input and returns the agent‚Äôs response.
- **response["messages"]**: After invoking the agent, we return the messages that the agent produces as a response.

---

## üß≥ **Implementing the Multi-Agent Workflow**

Now that we‚Äôve defined the agent and its tasks, we need to set up a **workflow** to coordinate the multi-turn conversation. The workflow will loop and interact with the agents until the conversation ends.

```python
from langgraph.types import interrupt

@entrypoint(checkpointer)
def workflow(messages):
    call_active_agent = call_travel_advisor
    while True:
        agent_messages = call_active_agent(messages).result()
        ai_msg = get_last_ai_msg(agent_messages)
        if not ai_msg.tool_calls:
            user_input = interrupt(value="Ready for user input.")
            messages = messages + [{"role": "user", "content": user_input}]
            continue

        messages = messages + agent_messages
        call_active_agent = get_next_agent(messages)
    return entrypoint.final(value=agent_messages[-1], save=messages)
```

#### **Explanation of the code:**
- **workflow()**: This is the main function that handles the multi-turn conversation. It repeatedly interacts with the agent until the conversation is complete.
- **call_active_agent**: This variable stores the function that will be called to interact with the agent. Initially, it calls the `call_travel_advisor` function.
- **while True**: This loop ensures the conversation continues until we break it manually.
- **call_active_agent(messages).result()**: This calls the agent and retrieves the response. It passes the conversation history (messages) as input to the agent and gets the agent's response.
- **ai_msg.tool_calls**: If the agent response includes a tool call (e.g., handoff to another agent), the system handles it accordingly.
- **user_input = interrupt(value="Ready for user input.")**: This is where the system waits for the user's input to continue the conversation.
- **get_next_agent(messages)**: This function determines the next agent to call based on the conversation history.

---

## üèôÔ∏è **Real-World Application: Virtual Travel Assistant**

This multi-turn conversation model can be used in a **virtual travel assistant** application. For example:
1. The user starts by asking about travel options.
2. The travel agent provides a response and offers more details.
3. The conversation is handed off to a hotel advisor agent to help the user book accommodations.
4. The user can return to the travel agent for additional questions about flights or itineraries.

This allows users to seamlessly interact with different agents (travel agent, hotel advisor, etc.) without having to start a new conversation each time.

---

## üöÄ **Alternative Examples**

### Example 1: Customer Support Bot with Multi-Agent System
Imagine you are building a **customer support chatbot** that can handle different topics (billing, technical support, shipping, etc.). When a user asks about billing issues, the system can transfer the conversation to the billing agent, and if the user then asks about shipping, the system can transfer them to the shipping agent. 

### Example 2: Virtual Health Assistant
In a **healthcare app**, the user might start by asking about symptoms. After receiving an initial response, the conversation could be handed off to a **medical professional agent** for further consultation, followed by a **pharmacy agent** if the user needs medication information.

### Example 3: Interactive Learning System
In an **interactive learning system**, a student might first ask questions related to math. After completing the math query, the system could hand over the conversation to an **English tutor agent** to help with grammar or vocabulary questions.

---

## **Conclusion** üéâ

We‚Äôve learned how to implement a multi-turn conversation system in a multi-agent environment. The steps included defining agents, tasks, and workflows that handle continuous interactions with users. By adding the ability for agents to transfer conversations (handoff) between them, the system becomes more flexible and capable of handling more complex use cases like travel assistance, customer support, and more!

# o3 mini:
# üöÄ Multi-Turn Conversations in a Multi-Agent Application (Functional API)

In this guide, we‚Äôll build an application that enables an end-user to engage in a multi-turn conversation with one or more agents using a **functional API**. Our system will:

- **Collect user input** via an interrupt.
- **Route control** back to the active agent based on conversation context.
- **Loop through conversation turns** until the interaction is complete.

This concept is useful for real-world applications like customer support chatbots or travel advisors, where the conversation involves multiple rounds of questioning and clarification.

---

## üîç Overview

### What We‚Äôre Building

Imagine a travel assistant application:
- **Travel Advisor Agent:** Recommends travel destinations.
- **Hotel Advisor Agent:** Provides hotel recommendations.

In a multi-turn conversation, the system will:
1. **Invoke an agent** to process the conversation.
2. **Check if the agent calls a transfer tool** (signaling that it wants to hand off control).
3. **Collect further user input** if no transfer is signaled.
4. **Loop** until the conversation reaches its conclusion.

### Real-World Example

**Customer Support Chatbot:**  
A customer interacts with a support bot:
- The bot first answers a query.
- If the answer is incomplete, it asks, "Do you need more help?"
- The user responds, and the conversation continues until the issue is resolved.

---

## üõ†Ô∏è Code Example & Detailed Explanation

Below is the code for a multi-turn conversation system using the functional API.

### Full Code Example

```python
from langgraph.func import entrypoint, task
from langgraph.prebuilt import create_react_agent
from langchain_core.tools import tool
from langgraph.types import interrupt

# 1. Define a tool to signal a handoff to a different agent (e.g., hotel advisor)
@tool(return_direct=True)
def transfer_to_hotel_advisor():
    """Ask hotel advisor agent for help."""
    # When this tool is invoked, it immediately exits the current agent's loop.
    return "Successfully transferred to hotel advisor"

# 2. Define an agent (travel advisor) that uses the handoff tool.
# Here, '...' represents additional tools you might want to include.
travel_advisor_tools = [transfer_to_hotel_advisor, ...]
travel_advisor = create_react_agent(model, travel_advisor_tools)

# 3. Create a task to call the travel advisor agent.
@task
def call_travel_advisor(messages):
    # Invoke the travel advisor with the full history of messages.
    response = travel_advisor.invoke({"messages": messages})
    # Return only the "messages" from the agent's response.
    return response["messages"]

# 4. Define the multi-turn conversation workflow.
@entrypoint(checkpointer)
def workflow(messages):
    # Start with the travel advisor as the active agent.
    call_active_agent = call_travel_advisor
    while True:
        # Call the active agent and wait for its response.
        agent_messages = call_active_agent(messages).result()
        # Extract the latest AI message from the response.
        ai_msg = get_last_ai_msg(agent_messages)
        
        # If there are no tool calls (no handoff request), collect user input.
        if not ai_msg.tool_calls:
            # Interrupt execution to get input from the user.
            user_input = interrupt(value="Ready for user input.")
            # Append the user's input to the conversation history.
            messages = messages + [{"role": "user", "content": user_input}]
            # Continue to the next loop iteration with the updated messages.
            continue

        # If a handoff is signaled, add the agent's messages to the conversation history.
        messages = messages + agent_messages
        # Decide which agent to call next based on the transfer tool invoked.
        call_active_agent = get_next_agent(messages)
    
    # When the loop ends, finalize the conversation.
    return entrypoint.final(value=agent_messages[-1], save=messages)
```

---

## üìö Line-by-Line Explanation

### **Imports and Setup**

```python
from langgraph.func import entrypoint, task
from langgraph.prebuilt import create_react_agent
from langchain_core.tools import tool
from langgraph.types import interrupt
```

- **`entrypoint, task`**: Decorators for defining the workflow and tasks.
- **`create_react_agent`**: Prebuilt function to create a ReAct agent.
- **`@tool`**: Decorator to create tools that agents can call.
- **`interrupt`**: Function used to pause execution and get user input.

---

### **1. Transfer Tool**

```python
@tool(return_direct=True)
def transfer_to_hotel_advisor():
    """Ask hotel advisor agent for help."""
    return "Successfully transferred to hotel advisor"
```

- **Purpose:**  
  - Signals that the travel advisor wants to hand off control to the hotel advisor.
- **`return_direct=True`:**  
  - Ensures the agent exits its loop immediately when this tool is called.
- **Return Value:**  
  - A simple string confirming the transfer, which the workflow later interprets to switch agents.

---

### **2. Define the Travel Advisor Agent**

```python
travel_advisor_tools = [transfer_to_hotel_advisor, ...]
travel_advisor = create_react_agent(model, travel_advisor_tools)
```

- **Purpose:**  
  - Create a specialized agent for travel recommendations.
- **`travel_advisor_tools`:**  
  - A list of tools the travel advisor can use, including our transfer tool.
- **`create_react_agent`:**  
  - Configures the agent with the provided language model and tools.

---

### **3. Create the Agent Task**

```python
@task
def call_travel_advisor(messages):
    response = travel_advisor.invoke({"messages": messages})
    return response["messages"]
```

- **Purpose:**  
  - Wraps the agent invocation into a callable task.
- **`invoke({"messages": messages})`:**  
  - Sends the current conversation history to the agent.
- **Return Value:**  
  - Extracts and returns the agent's response messages.

---

### **4. Define the Multi-Turn Workflow**

```python
@entrypoint(checkpointer)
def workflow(messages):
    call_active_agent = call_travel_advisor
    while True:
        agent_messages = call_active_agent(messages).result()
        ai_msg = get_last_ai_msg(agent_messages)
        if not ai_msg.tool_calls:
            user_input = interrupt(value="Ready for user input.")
            messages = messages + [{"role": "user", "content": user_input}]
            continue
        messages = messages + agent_messages
        call_active_agent = get_next_agent(messages)
    return entrypoint.final(value=agent_messages[-1], save=messages)
```

- **Purpose:**  
  - Orchestrates the multi-turn conversation.
- **`@entrypoint(checkpointer)`:**  
  - Marks the function as the starting point of the workflow and enables state saving.
- **`call_active_agent`:**  
  - Initially set to the travel advisor task.
- **Loop:**
  - **Agent Invocation:**  
    - Calls the active agent and waits for its response.
  - **`get_last_ai_msg`:**  
    - Retrieves the latest AI-generated message to check for tool calls.
  - **User Input:**  
    - If no tool calls are detected (no handoff), it interrupts and collects new user input.
  - **Update Messages:**  
    - The conversation history is updated with new messages.
  - **Agent Handoff:**  
    - If a tool call exists, it uses `get_next_agent` to determine the next active agent.
- **Final Return:**  
  - Ends the workflow by returning the last AI message and saving the complete conversation history.

---

## üîÑ Alternative Example Approaches

Here are three alternative approaches to implement multi-turn conversations in multi-agent systems:

### **Alternative Example 1: Simple Loop with Break Condition**

Instead of using an interrupt, you can use a simple input prompt within a loop:

```python
@entrypoint()
def simple_workflow(messages):
    call_active_agent = call_travel_advisor
    while True:
        agent_messages = call_active_agent(messages).result()
        messages += agent_messages
        ai_msg = get_last_ai_msg(agent_messages)
        if not ai_msg.tool_calls:
            # Use Python's built-in input() for simplicity.
            user_input = input("Your response: ")
            if user_input.lower() == "exit":
                break
            messages.append({"role": "user", "content": user_input})
        else:
            call_active_agent = get_next_agent(messages)
    return messages
```

**Key Differences:**
- Uses Python's `input()` instead of the `interrupt` function.
- Exits the conversation if the user types "exit".

---

### **Alternative Example 2: Fixed Conversation Rounds**

Set a fixed number of conversation turns before ending the conversation:

```python
@entrypoint()
def fixed_round_workflow(messages, rounds=3):
    call_active_agent = call_travel_advisor
    for _ in range(rounds):
        agent_messages = call_active_agent(messages).result()
        messages += agent_messages
        ai_msg = get_last_ai_msg(agent_messages)
        if not ai_msg.tool_calls:
            user_input = interrupt(value="Ready for user input.")
            messages.append({"role": "user", "content": user_input})
        else:
            call_active_agent = get_next_agent(messages)
    return messages
```

**Key Differences:**
- Limits the conversation to a fixed number of rounds.
- Ensures that the conversation will eventually end even if no handoff occurs.

---

### **Alternative Example 3: Conditional Handoff Based on Keywords**

Automatically switch agents based on keywords in the agent's response:

```python
@entrypoint()
def keyword_based_workflow(messages):
    call_active_agent = call_travel_advisor
    while True:
        agent_messages = call_active_agent(messages).result()
        messages += agent_messages
        ai_msg = get_last_ai_msg(agent_messages)
        # Check for a keyword in the AI message to trigger a handoff.
        if "hotel" in ai_msg.text.lower():
            call_active_agent = call_hotel_advisor
        else:
            user_input = interrupt(value="Ready for user input.")
            messages.append({"role": "user", "content": user_input})
        if "goodbye" in ai_msg.text.lower():
            break
    return messages
```

**Key Differences:**
- Uses keyword detection to decide when to hand off between agents.
- Ends the conversation if the AI message contains "goodbye".

---

## üéØ Key Takeaways

- **Multi-Turn Conversations:**  
  Allow for ongoing, interactive dialogue by collecting user input and routing conversation dynamically.

- **Functional API Benefits:**  
  - **Modularity:** Agents and tasks are defined as independent functions.
  - **Flexibility:** Easily switch between different agents based on conversation context.
  - **Scalability:** Extend the system by adding more agents or complex handoff logic.

- **Real-World Applications:**  
  Ideal for customer support, travel advisors, AI tutoring systems, or any scenario requiring dynamic, multi-turn interactions.

---

With these detailed explanations and alternative examples, you should now have a strong grasp of building multi-turn conversations in a multi-agent application using a functional API. This modular and flexible approach allows you to create sophisticated conversational systems tailored to various real-world applications. Happy coding!

---

# üß≥ How to Add Multi-Turn Conversations in a Multi-Agent Application

## Introduction to Multi-Turn Conversations

In many real-world applications like customer support or travel planning, users often need to interact with multiple agents, and the conversation doesn't always end in a single turn. In such cases, multi-turn conversations are crucial. A multi-turn conversation allows users to interact with different agents or systems in a sequence of exchanges until their request is fully satisfied. 

In this guide, we'll walk through how to implement **multi-turn conversations** in a **multi-agent** environment using Python. The example involves creating two agents: one to recommend travel destinations (`travel_advisor`) and another to recommend hotels (`hotel_advisor`). These agents can hand off tasks to each other to provide a seamless user experience.

### Key Concepts
- **Agents**: Independent systems that can perform specific tasks.
- **Multi-Turn Conversations**: Multiple exchanges between a user and an agent, possibly involving several agents.
- **Interrupts**: Signals to pause an agent's activity and wait for new user input.
- **Hand-offs**: Passing control between agents to continue the conversation.

### Real World Example

Imagine you're building a **travel assistant** application, where the user can ask for travel destination suggestions, hotel recommendations, or even transfer between agents. The system will guide the user step-by-step, and it will intelligently decide which agent should take over based on the conversation flow.

---

## üì¶ Setting Up the Environment

Before starting, we need to install the required packages and set up some environment variables.

### Install Required Packages

First, install the necessary libraries for LangGraph and LangChain:

```bash
pip install -U langgraph langchain-anthropic
```

We will also set up the API keys for integration.

```python
import getpass
import os

def _set_env(var: str):
    if not os.environ.get(var):
        os.environ[var] = getpass.getpass(f"{var}: ")

_set_env("ANTHROPIC_API_KEY")
```

This code ensures that we securely store the API keys required for interacting with the agents.

---

## üõ†Ô∏è Building the Agents

In this section, we'll define two agents: `travel_advisor` and `hotel_advisor`. We'll also create **tools** (functions) to interact with these agents.

### Define Travel Recommendations Tool

This tool will provide travel destination recommendations.

```python
import random
from typing_extensions import Literal

@tool
def get_travel_recommendations():
    """Get recommendation for travel destinations"""
    return random.choice(["aruba", "turks and caicos"])
```

- **Purpose**: This function randomly selects a travel destination from a list of options.
- **Real-World Use**: This could be used in an app where users want to explore new places to travel to.

### Define Hotel Recommendations Tool

Next, we define a tool that suggests hotels based on the travel destination.

```python
@tool
def get_hotel_recommendations(location: Literal["aruba", "turks and caicos"]):
    """Get hotel recommendations for a given destination."""
    return {
        "aruba": [
            "The Ritz-Carlton, Aruba (Palm Beach)",
            "Bucuti & Tara Beach Resort (Eagle Beach)"
        ],
        "turks and caicos": ["Grace Bay Club", "COMO Parrot Cay"],
    }[location]
```

- **Purpose**: This function returns hotel recommendations for a given location.
- **Real-World Use**: This would be used in a travel app where users can ask for hotel recommendations based on their chosen destination.

---

## üßë‚Äçüíª Create the Multi-Agent Network

Now, let's set up the multi-agent network. Each agent will use **React agents** for reactive behavior, which means they can respond to user queries and trigger specific actions (e.g., switching to another agent).

### Travel Advisor Agent

```python
from langgraph.prebuilt import create_react_agent

travel_advisor_tools = [
    get_travel_recommendations,
    transfer_to_hotel_advisor,
]
travel_advisor = create_react_agent(
    model,
    travel_advisor_tools,
    state_modifier=(
        "You are a general travel expert that can recommend travel destinations (e.g. countries, cities, etc). "
        "If you need hotel recommendations, ask 'hotel_advisor' for help. "
        "You MUST include human-readable response before transferring to another agent."
    ),
)
```

- **Purpose**: This agent recommends travel destinations and can ask the hotel advisor for help if needed.
- **Real-World Use**: This agent can be used in a travel app where users are looking for places to visit.

### Hotel Advisor Agent

```python
hotel_advisor_tools = [get_hotel_recommendations, transfer_to_travel_advisor]
hotel_advisor = create_react_agent(
    model,
    hotel_advisor_tools,
    state_modifier=(
        "You are a hotel expert that can provide hotel recommendations for a given destination. "
        "If you need help picking travel destinations, ask 'travel_advisor' for help."
        "You MUST include human-readable response before transferring to another agent."
    ),
)
```

- **Purpose**: This agent helps users with hotel recommendations and can ask the travel advisor for help if needed.
- **Real-World Use**: This agent could be used in a hotel booking app where users seek accommodation options.

---

## üîÑ Multi-Turn Workflow

Now that we have our agents set up, let's implement the workflow that allows multi-turn interactions between the agents and the user.

```python
@entrypoint(checkpointer=checkpointer)
def multi_turn_graph(messages, previous):
    previous = previous or []
    messages = add_messages(previous, messages)
    call_active_agent = call_travel_advisor
    while True:
        agent_messages = call_active_agent(messages).result()
        messages = add_messages(messages, agent_messages)
        
        ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))
        
        if not ai_msg.tool_calls:
            user_input = interrupt(value="Ready for user input.")
            human_message = {
                "role": "user",
                "content": user_input,
                "id": string_to_uuid(user_input),
            }
            messages = add_messages(messages, [human_message])
            continue

        tool_call = ai_msg.tool_calls[-1]
        if tool_call["name"] == "transfer_to_hotel_advisor":
            call_active_agent = call_hotel_advisor
        elif tool_call["name"] == "transfer_to_travel_advisor":
            call_active_agent = call_travel_advisor
        else:
            raise ValueError(f"Unexpected tool call: '{tool_call['name']}'")

    return entrypoint.final(value=agent_messages[-1], save=messages)
```

### Explanation of Code:
1. **`multi_turn_graph()`**: This function defines the workflow for multi-turn conversations. It calls the active agent and adds the new messages to the conversation.
2. **`interrupt(value="Ready for user input.")`**: This pauses the current conversation and waits for the user to provide new input.
3. **`tool_calls`**: These are the triggers that determine if we need to hand control to another agent. If the agent calls a transfer tool (e.g., `transfer_to_hotel_advisor`), the conversation is handed off to the appropriate agent.

---

## üìù Conclusion

### Use Cases in the Real World
- **Travel Assistance**: This setup allows users to seamlessly interact with multiple agents, such as travel advisors and hotel advisors, to get both travel and accommodation recommendations.
- **Customer Support**: In customer support systems, users may interact with different agents for various needs like billing inquiries, technical support, etc.

By understanding and implementing multi-turn conversations, you can create powerful and dynamic systems that can engage users in more natural and helpful ways.

---

### Alternative Examples

1. **Customer Service Chatbots**: A chatbot may need to hand off between agents depending on the type of inquiry, such as product inquiries, shipping information, or customer service escalation.

2. **Personal Assistant**: A virtual assistant could transfer between agents for tasks like weather updates, news, and entertainment recommendations.

3. **E-commerce Assistant**: In an e-commerce app, a shopping assistant might interact with different agents for product recommendations, order tracking, and customer feedback.

By experimenting with different agents and conversation flows, you'll get a deeper understanding of multi-turn conversations and how they enhance user interactions.

# o3 mini:
# üöÄ How to Add Multi-Turn Conversation in a Multi-Agent Application (Functional API)

In this guide, we will build a **multi-turn conversational system** using a functional API where multiple agents collaborate in a dialogue with an end-user. This means that instead of having a one-off interaction, the system will allow the conversation to continue over several turns. It‚Äôs like having a conversation with a team of experts where each expert (agent) can hand off the conversation to another as needed.

> **Real-World Example:**  
> Imagine a **virtual travel assistant**. One agent (the travel advisor) recommends destinations, and if the user asks for hotel recommendations, the conversation is handed off to another agent (the hotel advisor). The user can continue to ask follow-up questions (multi-turn), and the system collects new input to refine responses.

---

## üì¶ Setup

Before we start, we need to install the required packages and set up our environment. This ensures that we have access to the necessary libraries (LangGraph, LangChain, Anthropic‚Äôs ChatAnthropic, etc.).

```python
import getpass
import os

def _set_env(var: str):
    if not os.environ.get(var):
        os.environ[var] = getpass.getpass(f"{var}: ")

_set_env("ANTHROPIC_API_KEY")
```

**Explanation:**
- **Line 1-2:** Import Python‚Äôs built-in modules for handling environment variables.
- **Function `_set_env(var: str)`**:  
  - Checks if an environment variable (like `ANTHROPIC_API_KEY`) is already set.  
  - If not, it prompts the user to input the API key.
- **`_set_env("ANTHROPIC_API_KEY")`**: Calls the function to set the API key needed to use Anthropic‚Äôs language model.

---

## üõ†Ô∏è Defining Tools and Agents

We create tools that our agents will use and define two agents:
- **Travel Advisor:** Recommends travel destinations.
- **Hotel Advisor:** Provides hotel recommendations.

### Define Tools

```python
import random
from typing_extensions import Literal
from langchain_core.tools import tool

@tool
def get_travel_recommendations():
    """Get recommendation for travel destinations"""
    return random.choice(["aruba", "turks and caicos"])

@tool
def get_hotel_recommendations(location: Literal["aruba", "turks and caicos"]):
    """Get hotel recommendations for a given destination."""
    return {
        "aruba": [
            "The Ritz-Carlton, Aruba (Palm Beach)" 
            "Bucuti & Tara Beach Resort (Eagle Beach)"
        ],
        "turks and caicos": ["Grace Bay Club", "COMO Parrot Cay"],
    }[location]

@tool(return_direct=True)
def transfer_to_hotel_advisor():
    """Ask hotel advisor agent for help."""
    return "Successfully transferred to hotel advisor"

@tool(return_direct=True)
def transfer_to_travel_advisor():
    """Ask travel advisor agent for help."""
    return "Successfully transferred to travel advisor"
```

**Explanation:**
- **`@tool` decorator:**  
  - Marks a function as a tool that can be used by agents.  
  - `return_direct=True` means the tool returns a direct output (bypassing further processing) to signal an immediate handoff.
- **`get_travel_recommendations()`:** Randomly picks a travel destination.
- **`get_hotel_recommendations(location)`:** Returns hotel options based on the provided location.
- **`transfer_to_hotel_advisor()` and `transfer_to_travel_advisor()`:**  
  - These functions serve as signals for handoffs.  
  - When called, they indicate that the conversation should be transferred to the corresponding agent.

---

## ü§ñ Creating Agents with ReAct

We use the prebuilt `create_react_agent` to create our agents. This agent uses a language model (ChatAnthropic) with a set of tools and instructions (state_modifier).

```python
from langchain_anthropic import ChatAnthropic
from langgraph.prebuilt import create_react_agent
from langgraph.graph import add_messages
from langgraph.func import entrypoint, task
from langgraph.checkpoint.memory import MemorySaver
from langgraph.types import interrupt, Command
import uuid

model = ChatAnthropic(model="claude-3-5-sonnet-latest")

# Define travel advisor ReAct agent
travel_advisor_tools = [
    get_travel_recommendations,
    transfer_to_hotel_advisor,
]
travel_advisor = create_react_agent(
    model,
    travel_advisor_tools,
    state_modifier=(
        "You are a general travel expert that can recommend travel destinations (e.g. countries, cities, etc). "
        "If you need hotel recommendations, ask 'hotel_advisor' for help. "
        "You MUST include human-readable response before transferring to another agent."
    ),
)

@task
def call_travel_advisor(messages):
    # Invoke the travel advisor agent with the conversation history.
    response = travel_advisor.invoke({"messages": messages})
    return response["messages"]

# Define hotel advisor ReAct agent
hotel_advisor_tools = [
    get_hotel_recommendations,
    transfer_to_travel_advisor,
]
hotel_advisor = create_react_agent(
    model,
    hotel_advisor_tools,
    state_modifier=(
        "You are a hotel expert that can provide hotel recommendations for a given destination. "
        "If you need help picking travel destinations, ask 'travel_advisor' for help."
        "You MUST include human-readable response before transferring to another agent."
    ),
)

@task
def call_hotel_advisor(messages):
    response = hotel_advisor.invoke({"messages": messages})
    return response["messages"]
```

**Explanation:**
- **`ChatAnthropic`**: Initializes the language model.
- **`create_react_agent(model, tools, state_modifier)`**:  
  - Creates an agent using the provided model, tools, and instructions.
  - `state_modifier` tells the agent what its role is.
- **`@task` decorator**:  
  - Wraps a function as a task to be used within the workflow.
- **`call_travel_advisor()` and `call_hotel_advisor()`**:  
  - These tasks invoke their respective agents with the conversation history (messages) and return the agent‚Äôs responses.

---

## üîÑ Multi-Turn Conversation Workflow

The core of the multi-turn conversation is the workflow function, which loops through agent interactions and handles user input using an **interrupt**.

### Define Utility Functions

```python
def string_to_uuid(input_string):
    return str(uuid.uuid5(uuid.NAMESPACE_URL, input_string))
```

**Explanation:**
- **`string_to_uuid(input_string)`**:  
  - Generates a unique identifier for each user input based on its content.
  - This is used to deduplicate messages in the conversation history.

### Workflow Definition

```python
@entrypoint(checkpointer=MemorySaver())
def multi_turn_graph(messages, previous):
    previous = previous or []
    messages = add_messages(previous, messages)
    call_active_agent = call_travel_advisor
    while True:
        # Call the active agent and get its response.
        agent_messages = call_active_agent(messages).result()
        messages = add_messages(messages, agent_messages)
        
        # Retrieve the last AI message from the agent's response.
        ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))
        
        # If the last AI message does NOT include any tool calls, it means the agent finished.
        if not ai_msg.tool_calls:
            # Wait for new user input via interrupt.
            user_input = interrupt(value="Ready for user input.")
            # Create a human message with a unique ID and add it to the conversation.
            human_message = {
                "role": "user",
                "content": user_input,
                "id": string_to_uuid(user_input),
            }
            messages = add_messages(messages, [human_message])
            continue  # Loop back for the next turn.
        
        # Determine the next active agent based on the tool call in the last AI message.
        tool_call = ai_msg.tool_calls[-1]
        if tool_call["name"] == "transfer_to_hotel_advisor":
            call_active_agent = call_hotel_advisor
        elif tool_call["name"] == "transfer_to_travel_advisor":
            call_active_agent = call_travel_advisor
        else:
            raise ValueError(f"Expected transfer tool, got '{tool_call['name']}'")
    
    # Return the final agent message and the full conversation history.
    return entrypoint.final(value=agent_messages[-1], save=messages)
```

**Detailed Explanation (Line-by-Line):**
- **`@entrypoint(checkpointer=MemorySaver())`**:  
  - Marks this function as the starting point of the workflow.
  - `MemorySaver()` keeps track of conversation state between turns.
- **`def multi_turn_graph(messages, previous):`**:  
  - Accepts the new messages and previous conversation history.
- **`previous = previous or []`**:  
  - Initializes previous history if not provided.
- **`messages = add_messages(previous, messages)`**:  
  - Combines the previous conversation with the new input.
- **`call_active_agent = call_travel_advisor`**:  
  - Starts by calling the travel advisor agent.
- **`while True:`**:  
  - Begins an infinite loop to support multiple turns.
- **`agent_messages = call_active_agent(messages).result()`**:  
  - Invokes the active agent and waits for its response.
- **`messages = add_messages(messages, agent_messages)`**:  
  - Updates the conversation history with the agent‚Äôs responses.
- **`ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))`**:  
  - Searches for the last AI-generated message that might contain tool calls.
- **`if not ai_msg.tool_calls:`**:  
  - Checks if the agent did not call any transfer tool, meaning it has finished its part.
- **`user_input = interrupt(value="Ready for user input.")`**:  
  - Pauses the workflow to collect new input from the user.
- **Creating a human message with a unique ID:**  
  ```python
  human_message = {
      "role": "user",
      "content": user_input,
      "id": string_to_uuid(user_input),
  }
  ```
  - Ensures each input is uniquely identified so that duplicates are avoided.
- **`messages = add_messages(messages, [human_message])`**:  
  - Adds the human‚Äôs input to the conversation.
- **`continue`**:  
  - Restarts the loop to process the new user input.
- **Handoff Logic:**  
  - If the AI message contains a tool call (i.e., a transfer command), the workflow checks the tool‚Äôs name:
    - **`transfer_to_hotel_advisor`**: Switches the active agent to `call_hotel_advisor`.
    - **`transfer_to_travel_advisor`**: Switches back to `call_travel_advisor`.
- **`return entrypoint.final(value=agent_messages[-1], save=messages)`**:  
  - Once the loop terminates, the workflow returns the final AI message and saves the complete conversation history.

---

## üîÄ Alternative Examples

To further solidify your understanding, here are three alternative scenarios using similar multi-turn conversation techniques.

### **Example 1: Customer Support Chatbot**
- **Scenario:** A customer support chatbot where one agent handles technical issues and another handles billing queries.
- **Flow:**  
  1. The customer describes an issue.  
  2. The technical support agent responds.  
  3. If the issue is billing-related, the conversation is handed off to the billing agent.
- **Key Differences:**  
  - Replace travel tools with technical and billing tools.
  - Use transfer tools like `transfer_to_billing_agent()` and `transfer_to_tech_support_agent()`.

### **Example 2: Virtual Health Assistant**
- **Scenario:** A health assistant where one agent provides symptom checking and another offers medication advice.
- **Flow:**  
  1. The user describes symptoms.  
  2. The symptom checker responds.  
  3. If medication advice is needed, control is transferred to the medication advisor agent.
- **Key Differences:**  
  - Tools would include `get_symptom_analysis()` and `get_medication_advice()`.
  - Handoff tools like `transfer_to_medication_advisor()`.

### **Example 3: E-Commerce Shopping Assistant**
- **Scenario:** A shopping assistant that handles product recommendations and purchase queries.
- **Flow:**  
  1. The user asks for product recommendations.  
  2. The product advisor responds.  
  3. If the user wants to buy, the conversation is handed off to a purchase agent.
- **Key Differences:**  
  - Tools such as `get_product_recommendations()` and `get_purchase_options()`.
  - Transfer tools like `transfer_to_purchase_agent()`.

---

## üí° Conclusion

By following this guide, you have learned how to build a robust multi-turn conversational system using a multi-agent network with a functional API. This system:
- Supports **continuous dialogue** by waiting for user input (interrupts).
- Uses **handoff tools** to transfer control between specialized agents.
- Keeps track of the **conversation history** to provide context in each turn.

These concepts can be applied in various real-world applications, such as virtual travel assistants, customer support chatbots, health advisors, and e-commerce assistants. Experiment with the alternative examples to strengthen your understanding and adapt the system to your specific needs!

Happy coding! üöÄ

# How to Add Multi-Turn Conversation in a Multi-Agent Application (Functional API)

In this section, we'll explore how to implement multi-turn conversations in a multi-agent system using the **LangGraph** and **LangChain** frameworks. A **multi-turn conversation** means a back-and-forth exchange of dialogue between a user and a system, where each user input leads to a different response or action based on previous context. The goal is to have agents communicate with each other, transferring information as needed to provide the most relevant response.

We will break this down into easily understandable steps with examples. Let's look at a real-world use case, the travel assistant example, where multiple agents can help users with travel recommendations, hotels, and activities.

---

## üéØ Concept: Multi-Turn Conversations and Multi-Agent Systems

### What is a Multi-Turn Conversation?

A **multi-turn conversation** allows users to interact with a system in multiple stages, where each stage (turn) of the conversation builds on the previous one. This creates a dynamic, ongoing conversation that reflects user preferences and previous interactions. 

### What is a Multi-Agent System?

A **multi-agent system** consists of different agents that work independently or together to solve tasks. In our case, we have two agents:
1. **Travel Advisor**: Helps recommend travel destinations.
2. **Hotel Advisor**: Recommends hotels based on the chosen destination.

These agents can transfer control to one another if needed, such as when the travel advisor asks the hotel advisor for recommendations or vice versa.

---

## üõ†Ô∏è How Does the Code Work?

### 1. Setup Multi-Turn Conversation

Before we start coding, we need to set up the necessary environment and agents:

#### Install Required Packages
First, install the required libraries:

```bash
pip install langgraph langchain-anthropic
```

#### Define the Tools for Each Agent

The agents use tools to perform specific actions. Here's how we define the tools for our agents:

```python
import random
from typing_extensions import Literal
from langchain_core.tools import tool

# Tool to get travel recommendations
@tool
def get_travel_recommendations():
    """Get recommendation for travel destinations"""
    return random.choice(["Aruba", "Turks and Caicos"])

# Tool to get hotel recommendations for a destination
@tool
def get_hotel_recommendations(location: Literal["Aruba", "Turks and Caicos"]):
    """Get hotel recommendations for a given destination."""
    return {
        "Aruba": [
            "The Ritz-Carlton, Aruba (Palm Beach)",
            "Bucuti & Tara Beach Resort (Eagle Beach)",
        ],
        "Turks and Caicos": ["Grace Bay Club", "COMO Parrot Cay"],
    }[location]

# Tool to transfer the conversation to another agent
@tool(return_direct=True)
def transfer_to_hotel_advisor():
    """Ask hotel advisor agent for help."""
    return "Successfully transferred to hotel advisor"

@tool(return_direct=True)
def transfer_to_travel_advisor():
    """Ask travel advisor agent for help."""
    return "Successfully transferred to travel advisor"
```

### 2. Create Agents

Here we define our agents using **LangGraph**'s `create_react_agent`:

```python
from langgraph.prebuilt import create_react_agent
from langgraph.graph import add_messages
from langgraph.checkpoint.memory import MemorySaver
from langgraph.types import interrupt, Command

# Create Travel Advisor Agent
travel_advisor_tools = [get_travel_recommendations, transfer_to_hotel_advisor]
travel_advisor = create_react_agent(
    model,  # Use the model
    travel_advisor_tools,
    state_modifier=(
        "You are a general travel expert that can recommend travel destinations. "
        "If you need hotel recommendations, ask 'hotel_advisor' for help."
    ),
)

# Create Hotel Advisor Agent
hotel_advisor_tools = [get_hotel_recommendations, transfer_to_travel_advisor]
hotel_advisor = create_react_agent(
    model,
    hotel_advisor_tools,
    state_modifier=(
        "You are a hotel expert that can recommend hotels for a given destination."
        "If you need travel recommendations, ask 'travel_advisor' for help."
    ),
)
```

### 3. Handle Multi-Turn Conversations

Now, we will define the multi-turn conversation logic using **LangGraph's** `multi_turn_graph` function:

```python
import uuid
from langgraph.graph import add_messages
from langgraph.types import Command
from langgraph.checkpoint.memory import MemorySaver

# Function to create unique IDs for each message
def string_to_uuid(input_string):
    return str(uuid.uuid5(uuid.NAMESPACE_URL, input_string))

# Define multi-turn conversation function
def multi_turn_graph(messages, previous):
    previous = previous or []
    messages = add_messages(previous, messages)
    call_active_agent = call_travel_advisor  # Start with travel advisor

    while True:
        # Call the active agent (either travel_advisor or hotel_advisor)
        agent_messages = call_active_agent(messages).result()
        messages = add_messages(messages, agent_messages)

        # Check the last message from the agent
        ai_msg = next(m for m in reversed(agent_messages) if isinstance(m, AIMessage))

        # If there is no tool call, it means the agent is done and waiting for user input
        if not ai_msg.tool_calls:
            user_input = interrupt(value="Ready for user input.")
            human_message = {
                "role": "user",
                "content": user_input,
                "id": string_to_uuid(user_input),
            }
            messages = add_messages(messages, [human_message])
            continue

        # If a tool call is made, switch to the appropriate agent
        tool_call = ai_msg.tool_calls[-1]
        if tool_call["name"] == "transfer_to_hotel_advisor":
            call_active_agent = call_hotel_advisor
        elif tool_call["name"] == "transfer_to_travel_advisor":
            call_active_agent = call_travel_advisor
        else:
            raise ValueError(f"Unexpected tool call: {tool_call['name']}")

    return agent_messages[-1]  # Final message from the agent
```

### 4. Testing Multi-Turn Conversation

To test the multi-turn conversation, we simulate a back-and-forth dialogue where the user asks for travel recommendations, hotel suggestions, and activities to do:

```python
# Simulated user inputs
inputs = [
    {"role": "user", "content": "I want to go somewhere warm in the Caribbean", "id": str(uuid.uuid4())},
    Command(resume="Could you recommend a nice hotel in one of the areas and tell me which area it is?"),
    Command(resume="I like the first one. Could you recommend something to do near the hotel?")
]

# Test the multi-turn conversation
for idx, user_input in enumerate(inputs):
    print(f"--- Conversation Turn {idx + 1} ---")
    print(f"User: {user_input}")
    for update in multi_turn_graph.stream(user_input, config=thread_config, stream_mode="updates"):
        for node_id, value in update.items():
            if isinstance(value, list) and value:
                last_message = value[-1]
                if isinstance(last_message, dict) or last_message.type != "ai":
                    continue
                print(f"{node_id}: {last_message.content}")
```

---

## üß† Real-World Application

### Use Case: Travel Assistant Chatbot

This system can be used as a **travel assistant chatbot**. Imagine a user chatting with the assistant to plan a trip:
1. **Travel Advisor** helps with destination suggestions.
2. **Hotel Advisor** suggests hotels based on the destination.
3. The user may continue the conversation by asking about activities near the hotel.

For example, if a user says, "I want to go somewhere warm," the **travel advisor** could suggest destinations like Aruba or Turks and Caicos. If the user selects one, the **hotel advisor** will suggest hotels in that destination. The conversation can continue with activity suggestions near the hotel.

---

## üîÑ Conclusion

By using multi-turn conversations in a multi-agent system, you can create intelligent systems that provide dynamic and context-aware interactions. Each agent plays a specific role, and they can communicate with each other to provide the best possible response based on the user's input. This setup can be applied to various domains like customer service, e-commerce, and interactive assistants.

# o3 mini:
# üöÄ Multi-Turn Conversation in a Multi-Agent Application (Functional API)

In this guide, we will explain how to test a **multi-turn conversation** in a multi-agent application using a functional API. This example demonstrates how an end-user can engage in an ongoing conversation with multiple agents (e.g., a travel advisor and a hotel advisor). The system collects user inputs at different conversation turns (using interrupts) and routes these inputs back to the active agent.

> **Real-World Example:**  
> Imagine a **virtual travel assistant**. A user starts by asking, "I wanna go somewhere warm in the Caribbean." The travel advisor agent responds with destination recommendations. Then, the user asks follow-up questions like "Could you recommend a nice hotel?" and "I like the first one, what can I do near the hotel?"‚Äîeach time the system collects the input and routes it appropriately.

---

## üì¶ Setup and Required Imports

Before running our test conversation, we need to import necessary libraries, set up a unique thread configuration, and prepare a list of conversation inputs.

```python
import uuid
from langgraph.types import Command
# Note: multi_turn_graph is our previously defined workflow (not shown here).
```

**Explanation:**
- **`import uuid`**: We use UUIDs to generate unique thread IDs and message IDs.
- **`from langgraph.types import Command`**: The `Command` primitive is used to resume the conversation with new user input.
- **`multi_turn_graph`**: Represents our multi-turn conversation workflow (assumed defined earlier).

---

## üîÑ Testing the Multi-Turn Conversation

Below is the code snippet for testing our multi-turn conversation:

```python
# Create a unique thread configuration for this conversation
thread_config = {"configurable": {"thread_id": uuid.uuid4()}}

# Define conversation inputs for multiple turns
inputs = [
    # 1st turn: Initial user message.
    {
        "role": "user",
        "content": "i wanna go somewhere warm in the caribbean",
        "id": str(uuid.uuid4()),
    },
    # 2nd turn: Resume conversation with additional user input via Command.
    Command(
        resume="could you recommend a nice hotel in one of the areas and tell me which area it is."
    ),
    # 3rd turn: Another resume command for follow-up question.
    Command(
        resume="i like the first one. could you recommend something to do near the hotel?"
    ),
]

# Iterate through each conversation turn
for idx, user_input in enumerate(inputs):
    print()
    print(f"--- Conversation Turn {idx + 1} ---")
    print()
    print(f"User: {user_input}")
    print()
    # Stream conversation updates from the multi-turn workflow
    for update in multi_turn_graph.stream(
        user_input,
        config=thread_config,
        stream_mode="updates",
    ):
        # Iterate through updates from each node in the conversation graph
        for node_id, value in update.items():
            # Check if the update is a list with at least one message
            if isinstance(value, list) and value:
                last_message = value[-1]
                # If the last message is not an AI message, skip it
                if isinstance(last_message, dict) or last_message.type != "ai":
                    continue
                # Print the AI message content from the node
                print(f"{node_id}: {last_message.content}")
```

---

## üîç Line-by-Line Code Explanation

### 1. **Thread Configuration**

```python
thread_config = {"configurable": {"thread_id": uuid.uuid4()}}
```

- **Purpose:**  
  - Generates a unique `thread_id` using `uuid.uuid4()` which helps in identifying this conversation thread.
  - The `thread_config` is used to maintain state and context for the multi-turn conversation.

### 2. **Defining Conversation Inputs**

```python
inputs = [
    {
        "role": "user",
        "content": "i wanna go somewhere warm in the caribbean",
        "id": str(uuid.uuid4()),
    },
    Command(
        resume="could you recommend a nice hotel in one of the areas and tell me which area it is."
    ),
    Command(
        resume="i like the first one. could you recommend something to do near the hotel?"
    ),
]
```

- **Purpose:**  
  - **First input:** A dictionary representing the initial user message.  
    - **`role`:** Indicates this is a user message.
    - **`content`:** The user's query.
    - **`id`:** A unique ID generated for deduplication.
  - **Subsequent inputs:** Use the `Command(resume=...)` syntax to simulate the conversation resuming after the system interrupts for user input.

### 3. **Iterating Through Conversation Turns**

```python
for idx, user_input in enumerate(inputs):
    print()
    print(f"--- Conversation Turn {idx + 1} ---")
    print()
    print(f"User: {user_input}")
    print()
```

- **Purpose:**  
  - Loop through each turn in the conversation.
  - Print the turn number and display the user‚Äôs input for clarity.

### 4. **Streaming Conversation Updates**

```python
for update in multi_turn_graph.stream(
    user_input,
    config=thread_config,
    stream_mode="updates",
):
```

- **Purpose:**  
  - **`multi_turn_graph.stream(...)`**: Streams the conversation by passing the current input (`user_input`) along with the thread configuration.
  - **`stream_mode="updates"`**: Ensures that intermediate updates are also provided, not just the final output.

### 5. **Processing Each Node‚Äôs Update**

```python
for node_id, value in update.items():
    if isinstance(value, list) and value:
        last_message = value[-1]
        if isinstance(last_message, dict) or last_message.type != "ai":
            continue
        print(f"{node_id}: {last_message.content}")
```

- **Purpose:**  
  - Iterate through each node‚Äôs update in the returned update dictionary.
  - Check if the update is a list containing messages.
  - **`last_message = value[-1]`**: Retrieve the last message (expected to be an AI message).
  - **Message Type Check:**  
    - If the last message is not an AI message (for example, a human or tool message), skip printing.
  - Print the final AI message content from that node using its `node_id`.

---

## üìä Alternative Examples

To further grasp the concept, here are three alternative use-case scenarios:

### **Example 1: Customer Support Chatbot**
- **Scenario:**  
  - A multi-turn conversation between a customer and support agents for technical and billing issues.
- **Flow:**  
  1. User describes an issue.
  2. The technical support agent responds.
  3. If the issue involves billing, a handoff to the billing agent occurs.
- **Tools:**  
  - `get_tech_support_details()`, `transfer_to_billing_agent()`

### **Example 2: Virtual Health Assistant**
- **Scenario:**  
  - A patient interacts with a health assistant that switches between symptom checking and medication advice.
- **Flow:**  
  1. User describes symptoms.
  2. A symptom checker provides advice.
  3. If medication advice is needed, the conversation is transferred to a medication advisor agent.
- **Tools:**  
  - `analyze_symptoms()`, `transfer_to_medication_advisor()`

### **Example 3: E-Commerce Shopping Assistant**
- **Scenario:**  
  - A shopper converses with a virtual assistant for product recommendations and purchasing advice.
- **Flow:**  
  1. User asks for product suggestions.
  2. The product advisor responds.
  3. When the user shows interest in purchasing, the system hands off to a purchase advisor agent.
- **Tools:**  
  - `get_product_recommendations()`, `transfer_to_purchase_agent()`

---

## üí° Conclusion

This guide has walked you through:
- Setting up a multi-turn conversation system in a multi-agent network.
- Testing the conversation with user inputs and command resumes.
- Understanding the purpose and functionality of each code section.
- Alternative real-world examples that show how these techniques can be applied in various domains.

By mastering these concepts, you can build robust, interactive applications such as virtual travel assistants, customer support bots, health advisors, or shopping assistants.

Happy coding! üöÄ