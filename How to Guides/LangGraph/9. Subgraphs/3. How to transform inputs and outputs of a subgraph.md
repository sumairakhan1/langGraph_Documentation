# 3. How to transform inputs and outputs of a subgraph

# ğŸ”· **How to Transform Inputs and Outputs of a Subgraph in LangGraph**  

In **LangGraph**, a **subgraph** is a smaller component of a larger **parent graph**. Sometimes, we need to **transform inputs before passing them to a subgraph** and **transform outputs before returning them** to ensure proper communication between different levels of graphs.  

In this guide, we will:  
âœ… Understand how to **transform inputs and outputs of a subgraph**  
âœ… Learn by **breaking down an example step by step**  
âœ… See **real-world applications** where this concept can be useful  

---

## ğŸ”¹ **Why Do We Need to Transform Inputs and Outputs?**  

Imagine a **supervisor agent** that generates a report using multiple **ReAct agents**. Each **ReAct agent** might track messages, but the **supervisor only needs the final report** and user input. Since **each graph has its own state**, we must:  
âœ” Convert (transform) inputs **before calling** the subgraph  
âœ” Convert (transform) outputs **before returning** to the parent graph  

**Real-World Example:**  
A **project management system** where:  
- The **main system** (parent graph) tracks project progress  
- A **task manager subgraph** handles individual tasks  
- A **team chat subgraph** keeps track of messages  

Here, we must **transform data** between these components so that the project manager only sees **summary reports**, not chat messages.  

---

## ğŸ›  **Setting Up the Environment**  

First, install **LangGraph** if you haven't already:  

```python
!pip install -U langgraph
```

Now, letâ€™s define our **graphs and subgraphs** step by step.

---

# ğŸ”· **Step 1: Define the Grandchild Subgraph**  

The **grandchild subgraph** represents the lowest level of processing.  

### **ğŸ“Œ Code:**
```python
from typing_extensions import TypedDict
from langgraph.graph.state import StateGraph, START, END

# Define the state for the grandchild subgraph
class GrandChildState(TypedDict):
    my_grandchild_key: str

# Define the function to process the state
def grandchild_1(state: GrandChildState) -> GrandChildState:
    # Modify the input by adding ", how are you"
    return {"my_grandchild_key": state["my_grandchild_key"] + ", how are you"}

# Create the grandchild subgraph
grandchild = StateGraph(GrandChildState)
grandchild.add_node("grandchild_1", grandchild_1)

# Define edges (execution flow)
grandchild.add_edge(START, "grandchild_1")
grandchild.add_edge("grandchild_1", END)

# Compile the graph
grandchild_graph = grandchild.compile()

# Test invocation
print(grandchild_graph.invoke({"my_grandchild_key": "hi Bob"}))
```

### **ğŸ” Explanation:**  
âœ” **Defines** a new subgraph `grandchild_graph`  
âœ” Takes an input (e.g., `"hi Bob"`)  
âœ” **Transforms** it by adding `", how are you"`  
âœ” **Returns** the modified string  

**ğŸ“ Expected Output:**  
```json
{'my_grandchild_key': 'hi Bob, how are you'}
```

---

# ğŸ”· **Step 2: Define the Child Subgraph and Call the Grandchild**  

Now, we define a **child subgraph** that calls the **grandchild subgraph**.

### **ğŸ“Œ Code:**
```python
class ChildState(TypedDict):
    my_child_key: str

def call_grandchild_graph(state: ChildState) -> ChildState:
    # Transform input: rename key to match grandchild input format
    grandchild_graph_input = {"my_grandchild_key": state["my_child_key"]}
    
    # Call the grandchild subgraph
    grandchild_graph_output = grandchild_graph.invoke(grandchild_graph_input)
    
    # Transform output: rename key back to match child format
    return {"my_child_key": grandchild_graph_output["my_grandchild_key"] + " today?"}

# Create the child subgraph
child = StateGraph(ChildState)
child.add_node("child_1", call_grandchild_graph)

# Define execution flow
child.add_edge(START, "child_1")
child.add_edge("child_1", END)

# Compile the graph
child_graph = child.compile()

# Test invocation
print(child_graph.invoke({"my_child_key": "hi Bob"}))
```

### **ğŸ” Explanation:**  
âœ” **Transforms the input** before calling the grandchild (`"my_child_key"` â†’ `"my_grandchild_key"`)  
âœ” Calls the **grandchild subgraph**  
âœ” **Transforms the output** before returning (`"my_grandchild_key"` â†’ `"my_child_key"`)  

**ğŸ“ Expected Output:**  
```json
{'my_child_key': 'hi Bob, how are you today?'}
```

---

# ğŸ”· **Step 3: Define the Parent Graph and Call the Child**  

The **parent graph** will:  
1ï¸âƒ£ Add `"hi "` before calling the **child subgraph**  
2ï¸âƒ£ Call the **child subgraph**  
3ï¸âƒ£ Append `" bye!"` at the end  

### **ğŸ“Œ Code:**
```python
class ParentState(TypedDict):
    my_key: str

def parent_1(state: ParentState) -> ParentState:
    return {"my_key": "hi " + state["my_key"]}

def parent_2(state: ParentState) -> ParentState:
    return {"my_key": state["my_key"] + " bye!"}

def call_child_graph(state: ParentState) -> ParentState:
    # Transform input for child graph
    child_graph_input = {"my_child_key": state["my_key"]}
    
    # Call the child subgraph
    child_graph_output = child_graph.invoke(child_graph_input)
    
    # Transform output back for the parent graph
    return {"my_key": child_graph_output["my_child_key"]}

# Create the parent graph
parent = StateGraph(ParentState)
parent.add_node("parent_1", parent_1)
parent.add_node("child", call_child_graph)
parent.add_node("parent_2", parent_2)

# Define execution flow
parent.add_edge(START, "parent_1")
parent.add_edge("parent_1", "child")
parent.add_edge("child", "parent_2")
parent.add_edge("parent_2", END)

# Compile the parent graph
parent_graph = parent.compile()

# Test invocation
print(parent_graph.invoke({"my_key": "Bob"}))
```

### **ğŸ” Explanation:**  
âœ” **Step 1:** Adds `"hi "` before passing data  
âœ” **Step 2:** Calls the **child subgraph**, which in turn calls the **grandchild**  
âœ” **Step 3:** Adds `" bye!"` before returning the final output  

**ğŸ“ Expected Output:**  
```json
{'my_key': 'hi Bob, how are you today? bye!'}
```

---

# ğŸ¯ **Key Takeaways**  
âœ” **Each graph (parent, child, grandchild) has its own state**  
âœ” **Transformations are necessary** when calling subgraphs to match key names  
âœ” **Functions act as wrappers** to modify inputs/outputs before and after calling a subgraph  

---

# ğŸŒ **Real-World Use Cases**  

ğŸš€ **Chatbots with multiple layers:** A **main chatbot** (parent) talks to a **specialized agent** (child), which further calls **a sentiment analysis module** (grandchild).  

ğŸ“Š **Data Processing Pipelines:** A **parent graph** may handle data ingestion, a **child subgraph** may clean the data, and a **grandchild** may perform analysis.  

ğŸ” **AI Assistants for Business Reports:** The **parent agent** receives user queries, the **child agent** fetches relevant data, and the **grandchild agent** processes summaries.  

---

# âœ… **Conclusion**  

In **LangGraph**, transforming inputs and outputs between **parent and subgraphs** ensures smooth execution. By using **wrapper functions**, we can correctly **pass data** between different states while keeping graphs **independent and modular**.  

Would you like help implementing this in your project? ğŸš€