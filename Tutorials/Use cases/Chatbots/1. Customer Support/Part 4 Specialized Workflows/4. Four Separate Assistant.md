
**Now we'll start adding our specialized workflows. Each mini-workflow looks very similar to our full graph in Part 3, employing 5 nodes:**

enter_*: use the create_entry_node utility you defined above to add a ToolMessage signaling that the new specialized assistant is at the helm
Assistant: the prompt + llm combo that takes in the current state and either uses a tool, asks a question of the user, or ends the workflow (return to the primary assistant)
*_safe_tools: "read-only" tools the assistant can use without user confirmation.
*_sensitive_tools: tools with "write" access that require user confirmation (and will be assigned an interrupt_before when we compile the graph)
leave_skill: pop the dialog_state to signal that the primary assistant is back in control
Because of their similarities, we could define a factory function to generate these. Since this is a tutorial, we'll define them each explicitly.



# First, make the flight booking assistant dedicated to managing the user journey for updating and canceling flights. 


# Flight booking assistant
```python
builder.add_node(
    "enter_update_flight",
    create_entry_node("Flight Updates & Booking Assistant", "update_flight"),
)
builder.add_node("update_flight", Assistant(update_flight_runnable))
builder.add_edge("enter_update_flight", "update_flight")
builder.add_node(
    "update_flight_sensitive_tools",
    create_tool_node_with_fallback(update_flight_sensitive_tools),
)
builder.add_node(
    "update_flight_safe_tools",
    create_tool_node_with_fallback(update_flight_safe_tools),
)


def route_update_flight(
    state: State,
):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in update_flight_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "update_flight_safe_tools"
    return "update_flight_sensitive_tools"


builder.add_edge("update_flight_sensitive_tools", "update_flight")
builder.add_edge("update_flight_safe_tools", "update_flight")
builder.add_conditional_edges(
    "update_flight",
    route_update_flight,
    ["update_flight_sensitive_tools", "update_flight_safe_tools", "leave_skill", END],
)


# This node will be shared for exiting all specialized assistants
def pop_dialog_state(state: State) -> dict:
    """Pop the dialog stack and return to the main assistant.

    This lets the full graph explicitly track the dialog flow and delegate control
    to specific sub-graphs.
    """
    messages = []
    if state["messages"][-1].tool_calls:
        # Note: Doesn't currently handle the edge case where the llm performs parallel tool calls
        messages.append(
            ToolMessage(
                content="Resuming dialog with the host assistant. Please reflect on the past conversation and assist the user as needed.",
                tool_call_id=state["messages"][-1].tool_calls[0]["id"],
            )
        )
    return {
        "dialog_state": "pop",
        "messages": messages,
    }


builder.add_node("leave_skill", pop_dialog_state)
builder.add_edge("leave_skill", "primary_assistant")
```

# Next, create the car rental assistant graph to own all car rental needs. 

# Car rental assistant
```python
builder.add_node(
    "enter_book_car_rental",
    create_entry_node("Car Rental Assistant", "book_car_rental"),
)
builder.add_node("book_car_rental", Assistant(book_car_rental_runnable))
builder.add_edge("enter_book_car_rental", "book_car_rental")
builder.add_node(
    "book_car_rental_safe_tools",
    create_tool_node_with_fallback(book_car_rental_safe_tools),
)
builder.add_node(
    "book_car_rental_sensitive_tools",
    create_tool_node_with_fallback(book_car_rental_sensitive_tools),
)


def route_book_car_rental(
    state: State,
):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in book_car_rental_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "book_car_rental_safe_tools"
    return "book_car_rental_sensitive_tools"


builder.add_edge("book_car_rental_sensitive_tools", "book_car_rental")
builder.add_edge("book_car_rental_safe_tools", "book_car_rental")
builder.add_conditional_edges(
    "book_car_rental",
    route_book_car_rental,
    [
        "book_car_rental_safe_tools",
        "book_car_rental_sensitive_tools",
        "leave_skill",
        END,
    ],
)

```

# Then define the hotel booking workflow. 

# Hotel booking assistant
```python
builder.add_node(
    "enter_book_hotel", create_entry_node("Hotel Booking Assistant", "book_hotel")
)
builder.add_node("book_hotel", Assistant(book_hotel_runnable))
builder.add_edge("enter_book_hotel", "book_hotel")
builder.add_node(
    "book_hotel_safe_tools",
    create_tool_node_with_fallback(book_hotel_safe_tools),
)
builder.add_node(
    "book_hotel_sensitive_tools",
    create_tool_node_with_fallback(book_hotel_sensitive_tools),
)


def route_book_hotel(
    state: State,
):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    tool_names = [t.name for t in book_hotel_safe_tools]
    if all(tc["name"] in tool_names for tc in tool_calls):
        return "book_hotel_safe_tools"
    return "book_hotel_sensitive_tools"


builder.add_edge("book_hotel_sensitive_tools", "book_hotel")
builder.add_edge("book_hotel_safe_tools", "book_hotel")
builder.add_conditional_edges(
    "book_hotel",
    route_book_hotel,
    ["leave_skill", "book_hotel_safe_tools", "book_hotel_sensitive_tools", END],
)
```

# After that, define the excursion assistant. 

# Excursion assistant
```python
builder.add_node(
    "enter_book_excursion",
    create_entry_node("Trip Recommendation Assistant", "book_excursion"),
)
builder.add_node("book_excursion", Assistant(book_excursion_runnable))
builder.add_edge("enter_book_excursion", "book_excursion")
builder.add_node(
    "book_excursion_safe_tools",
    create_tool_node_with_fallback(book_excursion_safe_tools),
)
builder.add_node(
    "book_excursion_sensitive_tools",
    create_tool_node_with_fallback(book_excursion_sensitive_tools),
)


def route_book_excursion(
    state: State,
):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    tool_names = [t.name for t in book_excursion_safe_tools]
    if all(tc["name"] in tool_names for tc in tool_calls):
        return "book_excursion_safe_tools"
    return "book_excursion_sensitive_tools"


builder.add_edge("book_excursion_sensitive_tools", "book_excursion")
builder.add_edge("book_excursion_safe_tools", "book_excursion")
builder.add_conditional_edges(
    "book_excursion",
    route_book_excursion,
    ["book_excursion_safe_tools", "book_excursion_sensitive_tools", "leave_skill", END],
)

```
# Finally, create the primary assistant. 

# Primary assistant

```python
builder.add_node("primary_assistant", Assistant(assistant_runnable))
builder.add_node(
    "primary_assistant_tools", create_tool_node_with_fallback(primary_assistant_tools)
)


def route_primary_assistant(
    state: State,
):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    if tool_calls:
        if tool_calls[0]["name"] == ToFlightBookingAssistant.__name__:
            return "enter_update_flight"
        elif tool_calls[0]["name"] == ToBookCarRental.__name__:
            return "enter_book_car_rental"
        elif tool_calls[0]["name"] == ToHotelBookingAssistant.__name__:
            return "enter_book_hotel"
        elif tool_calls[0]["name"] == ToBookExcursion.__name__:
            return "enter_book_excursion"
        return "primary_assistant_tools"
    raise ValueError("Invalid route")

```
# The assistant can route to one of the delegated assistants,
# directly use a tool, or directly respond to the user
```python
builder.add_conditional_edges(
    "primary_assistant",
    route_primary_assistant,
    [
        "enter_update_flight",
        "enter_book_car_rental",
        "enter_book_hotel",
        "enter_book_excursion",
        "primary_assistant_tools",
        END,
    ],
)
builder.add_edge("primary_assistant_tools", "primary_assistant")
```

# Each delegated workflow can directly respond to the user
# When the user responds, we want to return to the currently active workflow
```python
def route_to_workflow(
    state: State,
) -> Literal[
    "primary_assistant",
    "update_flight",
    "book_car_rental",
    "book_hotel",
    "book_excursion",
]:
    """If we are in a delegated state, route directly to the appropriate assistant."""
    dialog_state = state.get("dialog_state")
    if not dialog_state:
        return "primary_assistant"
    return dialog_state[-1]


builder.add_conditional_edges("fetch_user_info", route_to_workflow)
```
# Compile graph
```python
memory = MemorySaver()
part_4_graph = builder.compile(
    checkpointer=memory,
    # Let the user approve or deny the use of sensitive tools
    interrupt_before=[
        "update_flight_sensitive_tools",
        "book_car_rental_sensitive_tools",
        "book_hotel_sensitive_tools",
        "book_excursion_sensitive_tools",
    ],
)
```


# 🚀 Building Specialized Workflows in a Multi-Agent Chatbot

In this section, we set up **specialized workflows** for different tasks (e.g., flight booking, car rental, hotel booking, excursion recommendations) in a multi-agent chatbot. Each workflow is represented as a sub-graph with five key nodes:

1. **enter_*** – A node that uses our `create_entry_node` utility to mark the handoff to a specialized assistant.  
2. **Assistant** – The node that contains the assistant's prompt and LLM logic to process the conversation (using its dedicated runnable).  
3. **\*_safe_tools** – A node for "read-only" tools that the assistant can call without user confirmation.  
4. **\*_sensitive_tools** – A node for tools that modify data ("write" actions) which require user confirmation (and are interrupted before execution).  
5. **leave_skill** – A node that “pops” the dialog state to signal that the specialized workflow is finished and control should return to the primary assistant.

This design pattern is similar to the **supervisor design pattern** in multi-agent systems. Let’s walk through the code step-by-step with explanations and real-world examples.

---

## 🔑 Key Concepts

- **Specialized Workflows:**  
  Divide the overall conversation into separate domains (flight, car, hotel, excursion) to provide focused and expert responses.

- **Handoff with ToolMessage:**  
  Use a special message (ToolMessage) to signal the switch of control from the primary assistant to a specialized assistant.

- **Routing Logic:**  
  Conditional edges determine which node to execute next, based on the tool calls made by the assistant.

- **Dialog State:**  
  A shared state that tracks the current workflow, ensuring a smooth handoff and eventual return to the primary assistant.

---

## ✨ Real-World Example

Imagine you’re using a travel assistant:
- You start by asking about your flight.
- Later, you decide to change your flight (handled by the **Flight Booking Assistant**).
- Then, you ask for a car rental, so control passes to the **Car Rental Assistant**.
- When you’re done with a specialized task, control returns to the primary assistant to answer general queries.
  
This ensures that each task is managed by an expert module, improving clarity and reliability.

---

## 🔧 Code Walkthrough

Below is the detailed explanation of the code that sets up these specialized workflows.

---

### 1️⃣ Flight Booking Assistant Workflow

#### **Creating the Entry Node**

```python
# Flight booking assistant entry node: marks handoff to Flight Booking Assistant.
builder.add_node(
    "enter_update_flight",
    create_entry_node("Flight Updates & Booking Assistant", "update_flight"),
)
```

- **Purpose:**  
  - The `create_entry_node` function creates a node that sends a ToolMessage indicating that control is handed over to the **Flight Updates & Booking Assistant**.  
  - It also updates the dialog state to `"update_flight"`.

#### **Setting Up the Flight Booking Assistant Node**

```python
builder.add_node("update_flight", Assistant(update_flight_runnable))
builder.add_edge("enter_update_flight", "update_flight")
```

- **Assistant Node:**  
  - Uses the `Assistant` class wrapped around `update_flight_runnable` (the flight booking logic).
  - An edge is added to connect the entry node to the flight booking assistant.

#### **Defining Tools for Flight Booking**

```python
builder.add_node(
    "update_flight_sensitive_tools",
    create_tool_node_with_fallback(update_flight_sensitive_tools),
)
builder.add_node(
    "update_flight_safe_tools",
    create_tool_node_with_fallback(update_flight_safe_tools),
)
```

- **Safe Tools:**  
  - Tools that search flights (read-only actions).
- **Sensitive Tools:**  
  - Tools that update or cancel flights (write actions requiring confirmation).

#### **Routing Logic for Flight Booking**

```python
def route_update_flight(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in update_flight_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "update_flight_safe_tools"
    return "update_flight_sensitive_tools"
```

- **Explanation:**
  - **`tools_condition(state)`:** Checks if any tool should be called.
  - **`did_cancel`:** If a `CompleteOrEscalate` call is detected, the workflow should exit (return `"leave_skill"`).
  - **Routing Decision:**  
    - If all tool calls are safe, route to `"update_flight_safe_tools"`.
    - Otherwise, route to `"update_flight_sensitive_tools"`.

#### **Connecting the Nodes**

```python
builder.add_edge("update_flight_sensitive_tools", "update_flight")
builder.add_edge("update_flight_safe_tools", "update_flight")
builder.add_conditional_edges(
    "update_flight",
    route_update_flight,
    ["update_flight_sensitive_tools", "update_flight_safe_tools", "leave_skill", END],
)
```

- **Edges:**  
  - Link the tool nodes back to the `update_flight` node.
  - Use conditional edges to decide which node to route next based on the output of `route_update_flight`.

---

### 2️⃣ Common Node: Leaving the Specialized Workflow

```python
def pop_dialog_state(state: State) -> dict:
    """Pop the dialog stack and return to the main assistant."""
    messages = []
    if state["messages"][-1].tool_calls:
        messages.append(
            ToolMessage(
                content="Resuming dialog with the host assistant. Please reflect on the past conversation and assist the user as needed.",
                tool_call_id=state["messages"][-1].tool_calls[0]["id"],
            )
        )
    return {
        "dialog_state": "pop",
        "messages": messages,
    }

builder.add_node("leave_skill", pop_dialog_state)
builder.add_edge("leave_skill", "primary_assistant")
```

- **Purpose:**  
  - The `pop_dialog_state` function pops the current workflow from the dialog state (indicating the specialized workflow is done).
  - It then sends a ToolMessage to signal the return to the primary assistant.
- **Edge:**  
  - Connects `"leave_skill"` to `"primary_assistant"`.

---

### 3️⃣ Car Rental Assistant Workflow

#### **Entry Node**

```python
builder.add_node(
    "enter_book_car_rental",
    create_entry_node("Car Rental Assistant", "book_car_rental"),
)
```

- **Handoff:**  
  - Marks the handoff to the **Car Rental Assistant** and sets the dialog state to `"book_car_rental"`.

#### **Assistant Node & Tool Nodes**

```python
builder.add_node("book_car_rental", Assistant(book_car_rental_runnable))
builder.add_edge("enter_book_car_rental", "book_car_rental")
builder.add_node(
    "book_car_rental_safe_tools",
    create_tool_node_with_fallback(book_car_rental_safe_tools),
)
builder.add_node(
    "book_car_rental_sensitive_tools",
    create_tool_node_with_fallback(book_car_rental_sensitive_tools),
)
```

- **Explanation:**  
  - Sets up the car rental assistant using its dedicated runnable and corresponding safe/sensitive tools.

#### **Routing for Car Rental**

```python
def route_book_car_rental(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in book_car_rental_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "book_car_rental_safe_tools"
    return "book_car_rental_sensitive_tools"

builder.add_edge("book_car_rental_sensitive_tools", "book_car_rental")
builder.add_edge("book_car_rental_safe_tools", "book_car_rental")
builder.add_conditional_edges(
    "book_car_rental",
    route_book_car_rental,
    ["book_car_rental_safe_tools", "book_car_rental_sensitive_tools", "leave_skill", END],
)
```

- **Similar Logic:**  
  - Routes between safe and sensitive nodes based on the tool calls, with an option to leave the workflow.

---

### 4️⃣ Hotel Booking & Excursion Workflows

The hotel and excursion workflows follow a similar pattern:

#### **Hotel Booking**

```python
builder.add_node(
    "enter_book_hotel", create_entry_node("Hotel Booking Assistant", "book_hotel")
)
builder.add_node("book_hotel", Assistant(book_hotel_runnable))
builder.add_edge("enter_book_hotel", "book_hotel")
builder.add_node(
    "book_hotel_safe_tools",
    create_tool_node_with_fallback(book_hotel_safe_tools),
)
builder.add_node(
    "book_hotel_sensitive_tools",
    create_tool_node_with_fallback(book_hotel_sensitive_tools),
)
```

- **Routing for Hotel Booking:**

```python
def route_book_hotel(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    tool_names = [t.name for t in book_hotel_safe_tools]
    if all(tc["name"] in tool_names for tc in tool_calls):
        return "book_hotel_safe_tools"
    return "book_hotel_sensitive_tools"

builder.add_edge("book_hotel_sensitive_tools", "book_hotel")
builder.add_edge("book_hotel_safe_tools", "book_hotel")
builder.add_conditional_edges(
    "book_hotel",
    route_book_hotel,
    ["leave_skill", "book_hotel_safe_tools", "book_hotel_sensitive_tools", END],
)
```

#### **Excursion**

```python
builder.add_node(
    "enter_book_excursion",
    create_entry_node("Trip Recommendation Assistant", "book_excursion"),
)
builder.add_node("book_excursion", Assistant(book_excursion_runnable))
builder.add_edge("enter_book_excursion", "book_excursion")
builder.add_node(
    "book_excursion_safe_tools",
    create_tool_node_with_fallback(book_excursion_safe_tools),
)
builder.add_node(
    "book_excursion_sensitive_tools",
    create_tool_node_with_fallback(book_excursion_sensitive_tools),
)
```

- **Routing for Excursion:**

```python
def route_book_excursion(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    tool_names = [t.name for t in book_excursion_safe_tools]
    if all(tc["name"] in tool_names for tc in tool_calls):
        return "book_excursion_safe_tools"
    return "book_excursion_sensitive_tools"

builder.add_edge("book_excursion_sensitive_tools", "book_excursion")
builder.add_edge("book_excursion_safe_tools", "book_excursion")
builder.add_conditional_edges(
    "book_excursion",
    route_book_excursion,
    ["book_excursion_safe_tools", "book_excursion_sensitive_tools", "leave_skill", END],
)
```

---

### 5️⃣ Primary Assistant Workflow

The primary assistant handles general queries and routes tasks to specialized workflows.

```python
builder.add_node("primary_assistant", Assistant(assistant_runnable))
builder.add_node(
    "primary_assistant_tools", create_tool_node_with_fallback(primary_assistant_tools)
)
```

- **Routing Logic for Primary Assistant:**

```python
def route_primary_assistant(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    if tool_calls:
        if tool_calls[0]["name"] == ToFlightBookingAssistant.__name__:
            return "enter_update_flight"
        elif tool_calls[0]["name"] == ToBookCarRental.__name__:
            return "enter_book_car_rental"
        elif tool_calls[0]["name"] == ToHotelBookingAssistant.__name__:
            return "enter_book_hotel"
        elif tool_calls[0]["name"] == ToBookExcursion.__name__:
            return "enter_book_excursion"
        return "primary_assistant_tools"
    raise ValueError("Invalid route")

builder.add_conditional_edges(
    "primary_assistant",
    route_primary_assistant,
    [
        "enter_update_flight",
        "enter_book_car_rental",
        "enter_book_hotel",
        "enter_book_excursion",
        "primary_assistant_tools",
        END,
    ],
)
builder.add_edge("primary_assistant_tools", "primary_assistant")
```

- **Explanation:**
  - The `route_primary_assistant` function checks which specialized tool (represented by a Pydantic model) was called, and routes the conversation to the corresponding entry node.
  - If no specialized tool is detected, it uses `primary_assistant_tools` for general queries.

#### **Returning to Active Workflow**

```python
def route_to_workflow(state: State) -> Literal["primary_assistant", "update_flight", "book_car_rental", "book_hotel", "book_excursion"]:
    """Route directly to the active workflow based on dialog_state."""
    dialog_state = state.get("dialog_state")
    if not dialog_state:
        return "primary_assistant"
    return dialog_state[-1]

builder.add_conditional_edges("fetch_user_info", route_to_workflow)
```

- **Purpose:**  
  - Ensures that when user responses come in, they are directed to the currently active workflow (if any) or to the primary assistant.

---

### 6️⃣ Compiling the Graph

```python
memory = MemorySaver()
part_4_graph = builder.compile(
    checkpointer=memory,
    # Let the user approve or deny the use of sensitive tools
    interrupt_before=[
        "update_flight_sensitive_tools",
        "book_car_rental_sensitive_tools",
        "book_hotel_sensitive_tools",
        "book_excursion_sensitive_tools",
    ],
)
```

- **MemorySaver:**  
  - Saves the state of the conversation (a checkpoint mechanism).
- **`interrupt_before`:**  
  - Specifies nodes where execution is paused to request user confirmation before running sensitive tools.

---

## 🎯 Summary

- **Specialized Workflows:**  
  - Each assistant (flight, car, hotel, excursion) is set up with entry, safe, sensitive, and leave nodes.
  
- **Handoff & Routing:**  
  - Use `create_entry_node` to mark transitions.
  - Conditional routing functions determine whether to use safe or sensitive tools, or whether to exit to the primary assistant.
  
- **Primary Assistant:**  
  - Routes the user's request to the appropriate specialized workflow based on detected intent.
  
- **Graph Compilation:**  
  - Combines all nodes and edges into a single graph, with interruptions for sensitive actions.

This modular design makes the chatbot more **scalable**, **maintainable**, and **user-friendly** by isolating complex logic into focused sub-workflows and providing clear handoffs between agents.

Feel free to ask if you need further clarification or additional examples!

# 🚀 **Understanding Specialized Workflows in a Multi-Agent Chatbot System**

In this guide, we'll break down how to create specialized workflows for a travel booking chatbot. This system assigns a dedicated assistant for each type of task—such as flight updates, hotel bookings, car rentals, and excursion recommendations—with a primary assistant that routes tasks appropriately. We'll explain every part in detail, line by line, and show real-world examples along the way.

---

## 📚 **Overview**

### What Are Specialized Workflows?
- **Specialized Workflows** separate complex tasks into smaller, focused sub-systems.
- Each workflow is managed by its own assistant (agent) that handles a specific domain:
  - ✈️ **Flight Booking Assistant**
  - 🏨 **Hotel Booking Assistant**
  - 🚗 **Car Rental Assistant**
  - 🏔️ **Excursion Assistant**
- A **Primary Assistant** acts as the supervisor that delegates tasks to these specialized assistants using a routing mechanism.

### Why Use This Approach?
- **Modularity:** Each assistant focuses on one domain, making it easier to update or improve without affecting others.
- **User Control:** Sensitive actions (like booking or cancellation) require user confirmation before proceeding.
- **Clarity:** The system clearly separates tasks, so the language model (LLM) is less likely to get confused by mixed contexts.
- **Real-World Example:** Think of a large travel agency where different departments handle flights, hotels, car rentals, and tours. The front desk (primary assistant) directs your inquiry to the appropriate department based on your needs.

---

## 🛠️ **Graph Structure for Specialized Workflows**

In our system, each specialized workflow consists of **5 key nodes**:

1. **Enter Node (enter_*)**  
   Uses the `create_entry_node` utility to insert a **ToolMessage** into the state, signaling the handoff to a specialized assistant.  
2. **Assistant Node**  
   The specialized assistant (e.g., Flight Booking Assistant) takes over with its dedicated prompt and LLM.
3. **Safe Tools Node (\*_safe_tools)**  
   Contains "read-only" tools that do not modify user data and can be used without confirmation.
4. **Sensitive Tools Node (\*_sensitive_tools)**  
   Contains tools that modify user data (e.g., making a booking) and require user confirmation. These nodes are set with `interrupt_before` when the graph is compiled.
5. **Leave Skill Node (leave_skill)**  
   Pops the dialog state to signal that the specialized assistant has finished and control is returned to the primary assistant.

Because these workflows are similar in structure, you could use a factory function to generate them, but here we define each explicitly for clarity.

---

## ✈️ **Flight Booking Assistant Workflow**

### Code Explanation:
```python
# Enter Node: Marks handoff to Flight Booking Assistant
builder.add_node(
    "enter_update_flight",
    create_entry_node("Flight Updates & Booking Assistant", "update_flight"),
)
```
- **Purpose:** Inserts a ToolMessage into the conversation indicating that the **Flight Booking Assistant** is now in control.
- **Parameters:**
  - `"Flight Updates & Booking Assistant"`: The name shown in the ToolMessage.
  - `"update_flight"`: The new dialog state to push onto the stack.

```python
# Assistant Node: The flight booking assistant processes flight updates
builder.add_node("update_flight", Assistant(update_flight_runnable))
builder.add_edge("enter_update_flight", "update_flight")
```
- **Purpose:** Adds the specialized Flight Booking Assistant node and connects it to the enter node.
- **`update_flight_runnable`**: Contains the prompt and LLM bound with flight-specific tools.

```python
# Define nodes for safe and sensitive tools for flight updates
builder.add_node(
    "update_flight_sensitive_tools",
    create_tool_node_with_fallback(update_flight_sensitive_tools),
)
builder.add_node(
    "update_flight_safe_tools",
    create_tool_node_with_fallback(update_flight_safe_tools),
)
```
- **Purpose:** Creates two nodes:
  - **Safe Tools Node:** For read-only tasks (e.g., searching flights).
  - **Sensitive Tools Node:** For write actions (e.g., updating or canceling flights).

### Conditional Routing for Flight Updates:
```python
def route_update_flight(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    # Check if the CompleteOrEscalate tool was invoked (user canceled or escalated)
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in update_flight_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "update_flight_safe_tools"
    return "update_flight_sensitive_tools"
```
- **Purpose:** Routes the conversation based on which tools are being called:
  - If the user cancels (via `CompleteOrEscalate`), return to **leave_skill**.
  - If only safe tools are invoked, continue to the **safe tools node**.
  - Otherwise, route to the **sensitive tools node**.

```python
builder.add_edge("update_flight_sensitive_tools", "update_flight")
builder.add_edge("update_flight_safe_tools", "update_flight")
builder.add_conditional_edges(
    "update_flight",
    route_update_flight,
    ["update_flight_sensitive_tools", "update_flight_safe_tools", "leave_skill", END],
)
```
- **Purpose:** Connects the nodes using conditional edges based on the routing logic defined above.

---

## 🚗 **Car Rental Assistant Workflow**

### Similar Steps for Car Rentals:
- **Enter Node:**  
  ```python
  builder.add_node(
      "enter_book_car_rental",
      create_entry_node("Car Rental Assistant", "book_car_rental"),
  )
  builder.add_node("book_car_rental", Assistant(book_car_rental_runnable))
  builder.add_edge("enter_book_car_rental", "book_car_rental")
  ```
  - Indicates that the **Car Rental Assistant** is now handling the conversation.
  
- **Safe & Sensitive Tools Nodes:**
  ```python
  builder.add_node(
      "book_car_rental_safe_tools",
      create_tool_node_with_fallback(book_car_rental_safe_tools),
  )
  builder.add_node(
      "book_car_rental_sensitive_tools",
      create_tool_node_with_fallback(book_car_rental_sensitive_tools),
  )
  ```
  - Splits the car rental tools into safe and sensitive categories.
  
- **Routing Logic for Car Rentals:**
  ```python
  def route_book_car_rental(state: State):
      route = tools_condition(state)
      if route == END:
          return END
      tool_calls = state["messages"][-1].tool_calls
      did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
      if did_cancel:
          return "leave_skill"
      safe_toolnames = [t.name for t in book_car_rental_safe_tools]
      if all(tc["name"] in safe_toolnames for tc in tool_calls):
          return "book_car_rental_safe_tools"
      return "book_car_rental_sensitive_tools"
  ```
  - Works similarly to the flight routing function, deciding which node to transition to based on tool invocations.
  
- **Connecting Edges:**
  ```python
  builder.add_edge("book_car_rental_sensitive_tools", "book_car_rental")
  builder.add_edge("book_car_rental_safe_tools", "book_car_rental")
  builder.add_conditional_edges(
      "book_car_rental",
      route_book_car_rental,
      ["book_car_rental_safe_tools", "book_car_rental_sensitive_tools", "leave_skill", END],
  )
  ```
  - Ensures proper flow within the car rental assistant workflow.

---

## 🏨 **Hotel Booking and 🏔️ Excursion Assistants**

### Hotel Booking:
- **Enter Node:**
  ```python
  builder.add_node(
      "enter_book_hotel", create_entry_node("Hotel Booking Assistant", "book_hotel")
  )
  builder.add_node("book_hotel", Assistant(book_hotel_runnable))
  builder.add_edge("enter_book_hotel", "book_hotel")
  ```
- **Safe & Sensitive Tools Nodes:**
  ```python
  builder.add_node(
      "book_hotel_safe_tools",
      create_tool_node_with_fallback(book_hotel_safe_tools),
  )
  builder.add_node(
      "book_hotel_sensitive_tools",
      create_tool_node_with_fallback(book_hotel_sensitive_tools),
  )
  ```
- **Routing Logic:**
  ```python
  def route_book_hotel(state: State):
      route = tools_condition(state)
      if route == END:
          return END
      tool_calls = state["messages"][-1].tool_calls
      did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
      if did_cancel:
          return "leave_skill"
      tool_names = [t.name for t in book_hotel_safe_tools]
      if all(tc["name"] in tool_names for tc in tool_calls):
          return "book_hotel_safe_tools"
      return "book_hotel_sensitive_tools"
  ```
- **Edges:**
  ```python
  builder.add_edge("book_hotel_sensitive_tools", "book_hotel")
  builder.add_edge("book_hotel_safe_tools", "book_hotel")
  builder.add_conditional_edges(
      "book_hotel",
      route_book_hotel,
      ["leave_skill", "book_hotel_safe_tools", "book_hotel_sensitive_tools", END],
  )
  ```

### Excursion Assistant:
- Follows the same structure as above with **enter**, **assistant**, **safe tools**, **sensitive tools**, and a **routing function** (`route_book_excursion`).

---

## 🌐 **Primary Assistant Workflow**

The **Primary Assistant** routes tasks to specialized assistants based on user intent.

### Primary Assistant Setup:
```python
builder.add_node("primary_assistant", Assistant(assistant_runnable))
builder.add_node(
    "primary_assistant_tools", create_tool_node_with_fallback(primary_assistant_tools)
)
```
- **Purpose:** The primary assistant can answer general queries and delegate specialized tasks.

### Routing Logic for Primary Assistant:
```python
def route_primary_assistant(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    if tool_calls:
        if tool_calls[0]["name"] == ToFlightBookingAssistant.__name__:
            return "enter_update_flight"
        elif tool_calls[0]["name"] == ToBookCarRental.__name__:
            return "enter_book_car_rental"
        elif tool_calls[0]["name"] == ToHotelBookingAssistant.__name__:
            return "enter_book_hotel"
        elif tool_calls[0]["name"] == ToBookExcursion.__name__:
            return "enter_book_excursion"
        return "primary_assistant_tools"
    raise ValueError("Invalid route")
```
- **Purpose:** Checks the latest tool call from the conversation and routes the user to the appropriate specialized assistant.
- **Example:** If the tool call is `ToBookCarRental`, the user is routed to the **Car Rental Assistant**.

### Connect Primary Assistant Edges:
```python
builder.add_conditional_edges(
    "primary_assistant",
    route_primary_assistant,
    [
        "enter_update_flight",
        "enter_book_car_rental",
        "enter_book_hotel",
        "enter_book_excursion",
        "primary_assistant_tools",
        END,
    ],
)
builder.add_edge("primary_assistant_tools", "primary_assistant")
```
- **Purpose:** Directs flow based on the routing function and returns to the primary assistant after specialized tasks.

### Returning Control to the Active Workflow:
```python
def route_to_workflow(state: State) -> Literal[
    "primary_assistant",
    "update_flight",
    "book_car_rental",
    "book_hotel",
    "book_excursion",
]:
    dialog_state = state.get("dialog_state")
    if not dialog_state:
        return "primary_assistant"
    return dialog_state[-1]

builder.add_conditional_edges("fetch_user_info", route_to_workflow)
```
- **Purpose:** Ensures that when a user responds, the graph knows which specialized assistant should handle the next message.

---

## 💾 **Compiling the Graph**

Finally, we compile the entire graph with memory checkpointing and set interrupts on sensitive tool nodes:
```python
memory = MemorySaver()
part_4_graph = builder.compile(
    checkpointer=memory,
    interrupt_before=[
        "update_flight_sensitive_tools",
        "book_car_rental_sensitive_tools",
        "book_hotel_sensitive_tools",
        "book_excursion_sensitive_tools",
    ],
)
```
- **`MemorySaver()`:** Persists the graph state so that if the conversation is interrupted, it can resume seamlessly.
- **`interrupt_before`:** Ensures that before any sensitive tool is executed, the system pauses for user confirmation.

---

## 🎯 **Key Takeaways**

- **Specialized Workflows:**  
  Each assistant (flight, hotel, car rental, excursion) handles a dedicated task, reducing complexity and improving accuracy.

- **Entry & Exit Nodes:**  
  Entry nodes signal handoff to a specialized assistant using a **ToolMessage**. The exit node (`leave_skill`) pops the dialog state to return control to the primary assistant.

- **Conditional Routing:**  
  Routing functions decide whether to use safe or sensitive tools, or to exit the specialized workflow based on the current state and tool calls.

- **Primary Assistant:**  
  Acts as a supervisor that delegates tasks to the appropriate specialized assistant and routes general queries.

- **Memory and Interrupts:**  
  Memory checkpointing preserves conversation state, and interrupts ensure sensitive actions require user confirmation.

---

## 🌍 **Real-World Application Example**

Imagine an airline’s virtual assistant system:
- A user starts by asking, "I need to change my flight date."
- The **Primary Assistant** interprets this and delegates the request to the **Flight Booking Assistant**.
- The **Flight Booking Assistant** uses safe tools to search for available flights.
- If the user confirms the flight change, the assistant then uses sensitive tools (which require an interrupt for confirmation) to update the booking.
- After the update, control is returned to the **Primary Assistant**, which can handle further queries like hotel bookings or car rentals.

This modular approach ensures that the system remains **robust, flexible, and user-friendly** even as additional features are added.

---

## 🎉 **Conclusion**

By breaking down the chatbot into specialized workflows, we achieve:
- **Enhanced modularity**: Each task is handled by a dedicated assistant.
- **Improved clarity**: The system knows exactly which assistant should handle a given user request.
- **Increased control**: Sensitive actions require user confirmation, reducing errors and increasing trust.

This design is ideal for complex, real-world systems such as airline customer support, where tasks range from simple queries to critical booking updates. With these techniques, you can build scalable and maintainable multi-agent chatbots that deliver excellent user experiences.

If you have any questions or need further clarification, feel free to ask! 😊

# 🌟 **Understanding Specialized Workflows in Assistant Graphs**  

This explanation will break down the **specialized workflows** concept using easy-to-understand language, line-by-line code explanations, real-world examples, and a structured approach with icons for clarity.  

---

## 🚀 **What Are Specialized Workflows?**  

Specialized workflows are like *mini-assistants* within a larger assistant system. Each workflow handles a specific task (like booking flights, renting cars, or reserving hotels) and works together with the primary assistant to provide a seamless user experience.  

### 🌍 **Real-World Example:**  
Imagine a **travel assistant app** where a user can:  
- ✈️ Book or update a flight  
- 🚗 Rent a car  
- 🏨 Book a hotel  
- 🏝️ Plan excursions  

Each task is handled by a different specialized assistant, but the user experiences it as one smooth conversation.  

---

## 🧩 **Key Components of Specialized Workflows**  

Each specialized workflow typically includes:  

1️⃣ **enter_\***: Signals the start of a specialized assistant.  
2️⃣ **Assistant**: The logic that handles user conversations and tasks.  
3️⃣ **\*_safe_tools**: Read-only tools (no user confirmation needed).  
4️⃣ **\*_sensitive_tools**: Write-access tools (need user approval).  
5️⃣ **leave_skill**: Ends the workflow and returns to the primary assistant.  

---

## 🔨 **Step-by-Step Explanation of the Code**  

### 1️⃣ **Create an Entry Node for Specialized Assistants**  
The entry node signals that a new assistant has taken over.

```python
from typing import Callable
from langchain_core.messages import ToolMessage

def create_entry_node(assistant_name: str, new_dialog_state: str) -> Callable:
    def entry_node(state: State) -> dict:
        tool_call_id = state["messages"][-1].tool_calls[0]["id"]
        return {
            "messages": [
                ToolMessage(
                    content=f"The assistant is now the {assistant_name}. Reflect on the above conversation between the host assistant and the user."
                            f" The user's intent is unsatisfied. Use the provided tools to assist the user. Remember, you are {assistant_name},"
                            " and the booking, update, or other action is not complete until you have successfully invoked the appropriate tool."
                            " If the user changes their mind, call CompleteOrEscalate to return control to the primary assistant.",
                    tool_call_id=tool_call_id,
                )
            ],
            "dialog_state": new_dialog_state,
        }
    return entry_node
```

### 💡 **Explanation:**  
- **`assistant_name`**: Name of the specialized assistant (e.g., "Flight Booking Assistant").  
- **`new_dialog_state`**: The current state, like "update_flight".  
- **`ToolMessage`**: Notifies the system that a specific assistant is now in charge.  
- **`tool_call_id`**: Helps track which action triggered the assistant.  

---

### 2️⃣ **Adding a Flight Booking Workflow**  
This handles tasks like updating or canceling flights.

```python
# Adding the entry point
builder.add_node(
    "enter_update_flight",
    create_entry_node("Flight Updates & Booking Assistant", "update_flight"),
)

# Main assistant logic for flight updates
builder.add_node("update_flight", Assistant(update_flight_runnable))
builder.add_edge("enter_update_flight", "update_flight")

# Safe and sensitive tools
builder.add_node("update_flight_safe_tools", create_tool_node_with_fallback(update_flight_safe_tools))
builder.add_node("update_flight_sensitive_tools", create_tool_node_with_fallback(update_flight_sensitive_tools))
```

### 💡 **Explanation:**  
- **`add_node`**: Adds a task or function.  
- **`add_edge`**: Connects tasks (like linking *enter_update_flight* to *update_flight*).  
- **Safe vs. Sensitive Tools**:  
  - ✅ **Safe tools**: E.g., checking flight details (no user approval).  
  - ⚠️ **Sensitive tools**: E.g., canceling a flight (requires confirmation).  

---

### 3️⃣ **Routing Between Tools**  
Decides which tools to use based on user actions.

```python
def route_update_flight(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)
    if did_cancel:
        return "leave_skill"
    safe_toolnames = [t.name for t in update_flight_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "update_flight_safe_tools"
    return "update_flight_sensitive_tools"
```

### 💡 **Explanation:**  
- **`tools_condition`**: Checks which tools are needed.  
- **`did_cancel`**: If the user cancels, it sends control back.  
- **Routing**: Directs to either safe or sensitive tools.  

---

### 4️⃣ **Exiting the Specialized Assistant**  
This brings control back to the main assistant.

```python
def pop_dialog_state(state: State) -> dict:
    messages = []
    if state["messages"][-1].tool_calls:
        messages.append(
            ToolMessage(
                content="Resuming dialog with the host assistant. Please reflect on the past conversation and assist the user as needed.",
                tool_call_id=state["messages"][-1].tool_calls[0]["id"],
            )
        )
    return {
        "dialog_state": "pop",
        "messages": messages,
    }

builder.add_node("leave_skill", pop_dialog_state)
builder.add_edge("leave_skill", "primary_assistant")
```

### 💡 **Explanation:**  
- **`pop_dialog_state`**: Pops the state stack, signaling a return to the main assistant.  
- **`leave_skill`**: The transition point between specialized and primary assistants.  

---

### 5️⃣ **Other Specialized Workflows**  
Similarly, we can add workflows for:  
- 🚗 **Car Rentals**  
- 🏨 **Hotel Bookings**  
- 🏝️ **Excursions**  

These workflows follow the **same pattern** as flight booking, just tailored to different tasks.  

---

### 6️⃣ **Primary Assistant Workflow**  
The **primary assistant** manages the entire conversation and delegates tasks to specialized assistants.

```python
builder.add_node("primary_assistant", Assistant(assistant_runnable))
builder.add_node("primary_assistant_tools", create_tool_node_with_fallback(primary_assistant_tools))

def route_primary_assistant(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    if tool_calls:
        if tool_calls[0]["name"] == ToFlightBookingAssistant.__name__:
            return "enter_update_flight"
        elif tool_calls[0]["name"] == ToBookCarRental.__name__:
            return "enter_book_car_rental"
        elif tool_calls[0]["name"] == ToHotelBookingAssistant.__name__:
            return "enter_book_hotel"
        elif tool_calls[0]["name"] == ToBookExcursion.__name__:
            return "enter_book_excursion"
    return "primary_assistant_tools"

builder.add_conditional_edges(
    "primary_assistant",
    route_primary_assistant,
    [
        "enter_update_flight",
        "enter_book_car_rental",
        "enter_book_hotel",
        "enter_book_excursion",
        "primary_assistant_tools",
        END,
    ],
)
```

### 💡 **Explanation:**  
- **`route_primary_assistant`**: Routes user requests to the correct assistant.  
- **`add_conditional_edges`**: Adds branching based on user requests (like going from flight booking to hotel booking).  

---

## 🏗️ **Compiling the Graph**  
Finally, we compile the entire graph with memory to track progress and interrupts for sensitive tasks.

```python
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
part_4_graph = builder.compile(
    checkpointer=memory,
    interrupt_before=[
        "update_flight_sensitive_tools",
        "book_car_rental_sensitive_tools",
        "book_hotel_sensitive_tools",
        "book_excursion_sensitive_tools",
    ],
)
```

### 💡 **Explanation:**  
- **`MemorySaver()`**: Keeps track of the conversation history.  
- **`interrupt_before`**: Stops before sensitive actions for user approval.  

---

## 🎯 **Summary of What We Achieved**  
- 🔄 Built **modular workflows** for complex user journeys.  
- 🧭 Implemented **dynamic routing** between specialized assistants.  
- 🔒 Incorporated **safe and sensitive tool usage** with user control.  
- 🔗 Ensured **smooth transitions** between specialized and primary assistants.  

---

## 💬 **Real-World Use Case Recap:**  
Imagine you’re chatting with a travel assistant app:  
- You ask: *"I want to update my flight."* ✈️  
- The assistant routes you to the **Flight Updates Assistant**.  
- After updating the flight, you say: *"Also, I need a hotel."* 🏨  
- The assistant smoothly transitions to the **Hotel Booking Assistant**, handling your request seamlessly.  

This **modular workflow** design ensures complex tasks feel like one smooth conversation! 🚀