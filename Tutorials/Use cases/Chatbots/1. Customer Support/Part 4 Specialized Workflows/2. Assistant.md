

# AssistantsÂ¶ 
This time we will create an assistant for every workflow. That means:

- Flight booking assistant
- Hotel booking assistant
- Car rental assistant
- Excursion assistant
- and finally, a "primary assistant" to route between these

If you're paying attention, you may recognize this as an example of the supervisor design pattern from our Multi-agent examples.

Below, define the Runnable objects to power each assistant. Each Runnable has a prompt, LLM, and schemas for the tools scoped to that assistant. Each specialized / delegated assistant additionally can call the CompleteOrEscalate tool to indicate that the control flow should be passed back to the primary assistant. This happens if it has successfully completed its work or if the user has changed their mind or needs assistance on something that beyond the scope of that particular workflow.

# Using Pydantic with LangChain

This notebook uses Pydantic v2 BaseModel, which requires langchain-core >= 0.3. Using langchain-core < 0.3 will result in errors due to mixing of Pydantic v1 and v2 BaseModels.

```python
from langchain_anthropic import ChatAnthropic
from langchain_community.tools.tavily_search import TavilySearchResults
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import Runnable, RunnableConfig

from pydantic import BaseModel, Field


class Assistant:
    def __init__(self, runnable: Runnable):
        self.runnable = runnable

    def __call__(self, state: State, config: RunnableConfig):
        while True:
            result = self.runnable.invoke(state)

            if not result.tool_calls and (
                not result.content
                or isinstance(result.content, list)
                and not result.content[0].get("text")
            ):
                messages = state["messages"] + [("user", "Respond with a real output.")]
                state = {**state, "messages": messages}
            else:
                break
        return {"messages": result}


class CompleteOrEscalate(BaseModel):
    """A tool to mark the current task as completed and/or to escalate control of the dialog to the main assistant,
    who can re-route the dialog based on the user's needs."""

    cancel: bool = True
    reason: str

    class Config:
        json_schema_extra = {
            "example": {
                "cancel": True,
                "reason": "User changed their mind about the current task.",
            },
            "example 2": {
                "cancel": True,
                "reason": "I have fully completed the task.",
            },
            "example 3": {
                "cancel": False,
                "reason": "I need to search the user's emails or calendar for more information.",
            },
        }


# Flight booking assistant

flight_booking_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling flight updates. "
            " The primary assistant delegates work to you whenever the user needs help updating their bookings. "
            "Confirm the updated flight details with the customer and inform them of any additional fees. "
            " When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\n\nCurrent user flight information:\n<Flights>\n{user_info}\n</Flights>"
            "\nCurrent time: {time}."
            "\n\nIf the user needs help, and none of your tools are appropriate for it, then"
            ' "CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.',
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

update_flight_safe_tools = [search_flights]
update_flight_sensitive_tools = [update_ticket_to_new_flight, cancel_ticket]
update_flight_tools = update_flight_safe_tools + update_flight_sensitive_tools
update_flight_runnable = flight_booking_prompt | llm.bind_tools(
    update_flight_tools + [CompleteOrEscalate]
)

# Hotel Booking Assistant
book_hotel_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling hotel bookings. "
            "The primary assistant delegates work to you whenever the user needs help booking a hotel. "
            "Search for available hotels based on the user's preferences and confirm the booking details with the customer. "
            " When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            '\n\nIf the user needs help, and none of your tools are appropriate for it, then "CompleteOrEscalate" the dialog to the host assistant.'
            " Do not waste the user's time. Do not make up invalid tools or functions."
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'what's the weather like this time of year?'\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'i need to figure out transportation while i'm there'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Hotel booking confirmed'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

book_hotel_safe_tools = [search_hotels]
book_hotel_sensitive_tools = [book_hotel, update_hotel, cancel_hotel]
book_hotel_tools = book_hotel_safe_tools + book_hotel_sensitive_tools
book_hotel_runnable = book_hotel_prompt | llm.bind_tools(
    book_hotel_tools + [CompleteOrEscalate]
)

# Car Rental Assistant
book_car_rental_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling car rental bookings. "
            "The primary assistant delegates work to you whenever the user needs help booking a car rental. "
            "Search for available car rentals based on the user's preferences and confirm the booking details with the customer. "
            " When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            "\n\nIf the user needs help, and none of your tools are appropriate for it, then "
            '"CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.'
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'what's the weather like this time of year?'\n"
            " - 'What flights are available?'\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Car rental booking confirmed'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

book_car_rental_safe_tools = [search_car_rentals]
book_car_rental_sensitive_tools = [
    book_car_rental,
    update_car_rental,
    cancel_car_rental,
]
book_car_rental_tools = book_car_rental_safe_tools + book_car_rental_sensitive_tools
book_car_rental_runnable = book_car_rental_prompt | llm.bind_tools(
    book_car_rental_tools + [CompleteOrEscalate]
)

# Excursion Assistant

book_excursion_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling trip recommendations. "
            "The primary assistant delegates work to you whenever the user needs help booking a recommended trip. "
            "Search for available trip recommendations based on the user's preferences and confirm the booking details with the customer. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " When searching, be persistent. Expand your query bounds if the first search returns no results. "
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            '\n\nIf the user needs help, and none of your tools are appropriate for it, then "CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.'
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'i need to figure out transportation while i'm there'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Excursion booking confirmed!'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

book_excursion_safe_tools = [search_trip_recommendations]
book_excursion_sensitive_tools = [book_excursion, update_excursion, cancel_excursion]
book_excursion_tools = book_excursion_safe_tools + book_excursion_sensitive_tools
book_excursion_runnable = book_excursion_prompt | llm.bind_tools(
    book_excursion_tools + [CompleteOrEscalate]
)


# Primary Assistant
class ToFlightBookingAssistant(BaseModel):
    """Transfers work to a specialized assistant to handle flight updates and cancellations."""

    request: str = Field(
        description="Any necessary followup questions the update flight assistant should clarify before proceeding."
    )


class ToBookCarRental(BaseModel):
    """Transfers work to a specialized assistant to handle car rental bookings."""

    location: str = Field(
        description="The location where the user wants to rent a car."
    )
    start_date: str = Field(description="The start date of the car rental.")
    end_date: str = Field(description="The end date of the car rental.")
    request: str = Field(
        description="Any additional information or requests from the user regarding the car rental."
    )

    class Config:
        json_schema_extra = {
            "example": {
                "location": "Basel",
                "start_date": "2023-07-01",
                "end_date": "2023-07-05",
                "request": "I need a compact car with automatic transmission.",
            }
        }


class ToHotelBookingAssistant(BaseModel):
    """Transfer work to a specialized assistant to handle hotel bookings."""

    location: str = Field(
        description="The location where the user wants to book a hotel."
    )
    checkin_date: str = Field(description="The check-in date for the hotel.")
    checkout_date: str = Field(description="The check-out date for the hotel.")
    request: str = Field(
        description="Any additional information or requests from the user regarding the hotel booking."
    )

    class Config:
        json_schema_extra = {
            "example": {
                "location": "Zurich",
                "checkin_date": "2023-08-15",
                "checkout_date": "2023-08-20",
                "request": "I prefer a hotel near the city center with a room that has a view.",
            }
        }


class ToBookExcursion(BaseModel):
    """Transfers work to a specialized assistant to handle trip recommendation and other excursion bookings."""

    location: str = Field(
        description="The location where the user wants to book a recommended trip."
    )
    request: str = Field(
        description="Any additional information or requests from the user regarding the trip recommendation."
    )

    class Config:
        json_schema_extra = {
            "example": {
                "location": "Lucerne",
                "request": "The user is interested in outdoor activities and scenic views.",
            }
        }


# The top-level assistant performs general Q&A and delegates specialized tasks to other assistants.
# The task delegation is a simple form of semantic routing / does simple intent detection
# llm = ChatAnthropic(model="claude-3-haiku-20240307")
llm = ChatAnthropic(model="claude-3-sonnet-20240229", temperature=1)

primary_assistant_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a helpful customer support assistant for Swiss Airlines. "
            "Your primary role is to search for flight information and company policies to answer customer queries. "
            "If a customer requests to update or cancel a flight, book a car rental, book a hotel, or get trip recommendations, "
            "delegate the task to the appropriate specialized assistant by invoking the corresponding tool. You are not able to make these types of changes yourself."
            " Only the specialized assistants are given permission to do this for the user."
            "The user is not aware of the different specialized assistants, so do not mention them; just quietly delegate through function calls. "
            "Provide detailed information to the customer, and always double-check the database before concluding that information is unavailable. "
            " When searching, be persistent. Expand your query bounds if the first search returns no results. "
            " If a search comes up empty, expand your search before giving up."
            "\n\nCurrent user flight information:\n<Flights>\n{user_info}\n</Flights>"
            "\nCurrent time: {time}.",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
primary_assistant_tools = [
    TavilySearchResults(max_results=1),
    search_flights,
    lookup_policy,
]
assistant_runnable = primary_assistant_prompt | llm.bind_tools(
    primary_assistant_tools
    + [
        ToFlightBookingAssistant,
        ToBookCarRental,
        ToHotelBookingAssistant,
        ToBookExcursion,
    ]
)

```

# ð¤ Creating Specialized Assistants for a Multi-Workflow Chatbot

In this section, we build on previous concepts by creating **specialized assistants** for different tasksâlike flight booking, hotel booking, car rentals, and excursionsâplus a **primary assistant** that acts as a supervisor. This design follows the **supervisor design pattern** (or multi-agent system), where each agent (assistant) handles a specific domain. This setup improves accuracy and user experience by ensuring that each assistant is an expert in its domain.

Let's break down the code and its purpose step-by-step.

---

## ð¯ Overview

- **Specialized Assistants:**  
  - **Flight Booking Assistant**
  - **Hotel Booking Assistant**
  - **Car Rental Assistant**
  - **Excursion Assistant**

- **Primary Assistant:**  
  Routes user requests to the appropriate specialized assistant.

- **CompleteOrEscalate Tool:**  
  A mechanism that allows any specialized assistant to **complete its task** or **escalate control** back to the primary assistant if the task is done, if the user changes their mind, or if the assistant cannot handle the query.

---

## ð  The `Assistant` Class

This class wraps a **Runnable** (the core processing unit) and ensures that the assistant produces a non-empty, valid response.

```python
class Assistant:
    def __init__(self, runnable: Runnable):
        self.runnable = runnable  # Store the runnable logic that powers the assistant

    def __call__(self, state: State, config: RunnableConfig):
        while True:
            result = self.runnable.invoke(state)  # Invoke the runnable with the current state
            # Check if the response is valid; if not, prompt the model for a real output
            if not result.tool_calls and (
                not result.content
                or isinstance(result.content, list)
                and not result.content[0].get("text")
            ):
                # Append a re-prompt message to the conversation history
                messages = state["messages"] + [("user", "Respond with a real output.")]
                state = {**state, "messages": messages}
            else:
                break  # Break out if a valid response is obtained
        return {"messages": result}  # Return the final messages from the assistant
```

### ð Explanation:
- **`__init__`:**  
  Stores the `runnable` object, which is the combination of a prompt, LLM, and tool bindings.

- **`__call__`:**  
  Runs the assistant logic repeatedly until a valid response is generated.  
  - **`invoke(state)`:** Calls the LLM with the current state.  
  - **Response Validation:** Checks if the output is empty or missing text, and if so, adds a message prompting for a real output.  
  - **Return:** Once a valid response is obtained, it returns the updated messages.

---

## ð§ The `CompleteOrEscalate` Tool

This tool allows specialized assistants to either finish their task or transfer control back to the primary assistant.

```python
from pydantic import BaseModel, Field

class CompleteOrEscalate(BaseModel):
    """A tool to mark the current task as completed and/or to escalate control of the dialog to the main assistant."""
    cancel: bool = True  # Indicates whether to cancel the current task
    reason: str         # Reason for canceling or escalating

    class Config:
        json_schema_extra = {
            "example": {
                "cancel": True,
                "reason": "User changed their mind about the current task.",
            },
            "example 2": {
                "cancel": True,
                "reason": "I have fully completed the task.",
            },
            "example 3": {
                "cancel": False,
                "reason": "I need to search the user's emails or calendar for more information.",
            },
        }
```

### ð Explanation:
- **`CompleteOrEscalate` Fields:**  
  - `cancel`: A flag to indicate if the current task should be terminated.  
  - `reason`: A string providing context (e.g., task completed, user changed their mind).

- **Pydantic's BaseModel:**  
  Ensures that data adheres to a specified schema, which is helpful for validation and documentation.

---

## âï¸ Flight Booking Assistant

This assistant focuses on updating flight bookings. It uses both **safe tools** (like searching flights) and **sensitive tools** (like updating or canceling flights).

```python
from langchain_core.prompts import ChatPromptTemplate
from datetime import datetime

flight_booking_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling flight updates. "
            "The primary assistant delegates work to you whenever the user needs help updating their bookings. "
            "Confirm the updated flight details with the customer and inform them of any additional fees. "
            "When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\n\nCurrent user flight information:\n<Flights>\n{user_info}\n</Flights>"
            "\nCurrent time: {time}."
            "\n\nIf the user needs help, and none of your tools are appropriate for it, then"
            ' "CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.',
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

### ð Explanation:
- **Prompt Template:**  
  Defines the system message that sets the context for flight booking.  
  - **`{user_info}`** and **`{time}`** are placeholders for dynamic data.
- **`partial(time=datetime.now)`:**  
  Pre-fills the current time so that every invocation gets a fresh timestamp.

Next, we bind the tools for flight booking:

```python
update_flight_safe_tools = [search_flights]  # Tools for read-only actions
update_flight_sensitive_tools = [update_ticket_to_new_flight, cancel_ticket]  # Tools for modifying bookings
update_flight_tools = update_flight_safe_tools + update_flight_sensitive_tools
update_flight_runnable = flight_booking_prompt | llm.bind_tools(
    update_flight_tools + [CompleteOrEscalate]
)
```

### ð Explanation:
- **Tool Separation:**  
  - **Safe Tools:** For actions like searching flights.
  - **Sensitive Tools:** For actions that change bookings.
- **Binding Tools:**  
  Combines tools with the prompt using the `|` operator, effectively creating a runnable workflow.
- **`CompleteOrEscalate`:**  
  Added so the assistant can escalate control if needed.

---

## ð¨ Hotel Booking Assistant

Similarly, the hotel booking assistant is designed to handle hotel-related queries.

```python
book_hotel_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling hotel bookings. "
            "The primary assistant delegates work to you whenever the user needs help booking a hotel. "
            "Search for available hotels based on the user's preferences and confirm the booking details with the customer. "
            "When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            '\n\nIf the user needs help, and none of your tools are appropriate for it, then "CompleteOrEscalate" the dialog to the host assistant.'
            " Do not waste the user's time. Do not make up invalid tools or functions."
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'what's the weather like this time of year?'\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'i need to figure out transportation while i'm there'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Hotel booking confirmed'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

### ð Explanation:
- **Prompt:**  
  Provides a clear instruction set specific to hotel bookings.
- **Tool Binding:**

```python
book_hotel_safe_tools = [search_hotels]
book_hotel_sensitive_tools = [book_hotel, update_hotel, cancel_hotel]
book_hotel_tools = book_hotel_safe_tools + book_hotel_sensitive_tools
book_hotel_runnable = book_hotel_prompt | llm.bind_tools(
    book_hotel_tools + [CompleteOrEscalate]
)
```

- **Safe Tools:** For searching hotels.
- **Sensitive Tools:** For booking, updating, or canceling a hotel reservation.
- **CompleteOrEscalate:** Enables escalation if the assistant cannot handle the task.

---

## ð Car Rental Assistant

This assistant handles car rental bookings similarly.

```python
book_car_rental_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling car rental bookings. "
            "The primary assistant delegates work to you whenever the user needs help booking a car rental. "
            "Search for available car rentals based on the user's preferences and confirm the booking details with the customer. "
            "When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            " Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            "\n\nIf the user needs help, and none of your tools are appropriate for it, then "
            '"CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.'
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'what's the weather like this time of year?'\n"
            " - 'What flights are available?'\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Car rental booking confirmed'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

And then bind the tools:

```python
book_car_rental_safe_tools = [search_car_rentals]
book_car_rental_sensitive_tools = [
    book_car_rental,
    update_car_rental,
    cancel_car_rental,
]
book_car_rental_tools = book_car_rental_safe_tools + book_car_rental_sensitive_tools
book_car_rental_runnable = book_car_rental_prompt | llm.bind_tools(
    book_car_rental_tools + [CompleteOrEscalate]
)
```

### ð Explanation:
- **Prompt & Tools:**  
  Designed specifically for car rental queries with both safe and sensitive operations.
- **`CompleteOrEscalate`:**  
  Again, added for flexibility in handling unexpected queries or user changes.

---

## ðï¸ Excursion Assistant

This assistant manages trip recommendations and excursion bookings.

```python
book_excursion_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling trip recommendations. "
            "The primary assistant delegates work to you whenever the user needs help booking a recommended trip. "
            "Search for available trip recommendations based on the user's preferences and confirm the booking details with the customer. "
            "If you need more information or the customer changes their mind, escalate the task back to the main assistant."
            "When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "Remember that a booking isn't completed until after the relevant tool has successfully been used."
            "\nCurrent time: {time}."
            '\n\nIf the user needs help, and none of your tools are appropriate for it, then "CompleteOrEscalate" the dialog to the host assistant. Do not waste the user\'s time. Do not make up invalid tools or functions.'
            "\n\nSome examples for which you should CompleteOrEscalate:\n"
            " - 'nevermind i think I'll book separately'\n"
            " - 'i need to figure out transportation while i'm there'\n"
            " - 'Oh wait i haven't booked my flight yet i'll do that first'\n"
            " - 'Excursion booking confirmed!'",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

And bind its tools:

```python
book_excursion_safe_tools = [search_trip_recommendations]
book_excursion_sensitive_tools = [book_excursion, update_excursion, cancel_excursion]
book_excursion_tools = book_excursion_safe_tools + book_excursion_sensitive_tools
book_excursion_runnable = book_excursion_prompt | llm.bind_tools(
    book_excursion_tools + [CompleteOrEscalate]
)
```

### ð Explanation:
- **Prompt:**  
  Focused on handling excursions and trip recommendations.
- **Tool Separation:**  
  Again, differentiates between safe and sensitive actions.
- **CompleteOrEscalate:**  
  Provides a route back to the primary assistant if necessary.

---

## ð Primary Assistant

The primary assistant serves as the **frontline interface** for the user. It performs general queries and routes specialized tasks to the respective assistants.

### Specialized Data Transfer Models

Using **Pydantic**, we define models to capture user requests and transfer control to the specialized assistants.

```python
from pydantic import BaseModel, Field

class ToFlightBookingAssistant(BaseModel):
    """Transfers work to a specialized assistant to handle flight updates and cancellations."""
    request: str = Field(
        description="Any necessary followup questions the update flight assistant should clarify before proceeding."
    )

class ToBookCarRental(BaseModel):
    """Transfers work to a specialized assistant to handle car rental bookings."""
    location: str = Field(
        description="The location where the user wants to rent a car."
    )
    start_date: str = Field(description="The start date of the car rental.")
    end_date: str = Field(description="The end date of the car rental.")
    request: str = Field(
        description="Any additional information or requests from the user regarding the car rental."
    )
    class Config:
        json_schema_extra = {
            "example": {
                "location": "Basel",
                "start_date": "2023-07-01",
                "end_date": "2023-07-05",
                "request": "I need a compact car with automatic transmission.",
            }
        }

class ToHotelBookingAssistant(BaseModel):
    """Transfer work to a specialized assistant to handle hotel bookings."""
    location: str = Field(
        description="The location where the user wants to book a hotel."
    )
    checkin_date: str = Field(description="The check-in date for the hotel.")
    checkout_date: str = Field(description="The check-out date for the hotel.")
    request: str = Field(
        description="Any additional information or requests from the user regarding the hotel booking."
    )
    class Config:
        json_schema_extra = {
            "example": {
                "location": "Zurich",
                "checkin_date": "2023-08-15",
                "checkout_date": "2023-08-20",
                "request": "I prefer a hotel near the city center with a room that has a view.",
            }
        }

class ToBookExcursion(BaseModel):
    """Transfers work to a specialized assistant to handle trip recommendation and other excursion bookings."""
    location: str = Field(
        description="The location where the user wants to book a recommended trip."
    )
    request: str = Field(
        description="Any additional information or requests from the user regarding the trip recommendation."
    )
    class Config:
        json_schema_extra = {
            "example": {
                "location": "Lucerne",
                "request": "The user is interested in outdoor activities and scenic views.",
            }
        }
```

### ð Explanation:
- **Pydantic Models:**  
  Define the **structure of data** to be passed from the primary assistant to the specialized assistants.  
- **Examples Provided:**  
  Offer guidance on what kind of data is expected for each task.

### Primary Assistant Runnable

Finally, we define the primary assistant's prompt and bind it with its set of tools.

```python
llm = ChatAnthropic(model="claude-3-sonnet-20240229", temperature=1)

primary_assistant_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a helpful customer support assistant for Swiss Airlines. "
            "Your primary role is to search for flight information and company policies to answer customer queries. "
            "If a customer requests to update or cancel a flight, book a car rental, book a hotel, or get trip recommendations, "
            "delegate the task to the appropriate specialized assistant by invoking the corresponding tool. You are not able to make these types of changes yourself."
            " Only the specialized assistants are given permission to do this for the user."
            "The user is not aware of the different specialized assistants, so do not mention them; just quietly delegate through function calls. "
            "Provide detailed information to the customer, and always double-check the database before concluding that information is unavailable. "
            "When searching, be persistent. Expand your query bounds if the first search returns no results. "
            "If a search comes up empty, expand your search before giving up."
            "\n\nCurrent user flight information:\n<Flights>\n{user_info}\n</Flights>"
            "\nCurrent time: {time}.",
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

primary_assistant_tools = [
    TavilySearchResults(max_results=1),
    search_flights,
    lookup_policy,
]
assistant_runnable = primary_assistant_prompt | llm.bind_tools(
    primary_assistant_tools
    + [
        ToFlightBookingAssistant,
        ToBookCarRental,
        ToHotelBookingAssistant,
        ToBookExcursion,
    ]
)
```

### ð Explanation:
- **Primary Assistant Prompt:**  
  Guides the primary assistant to handle general queries and **delegate specialized tasks**.  
- **Tool Binding:**  
  Combines tools for flight searches and policy lookups with the Pydantic models that enable task delegation.
- **`assistant_runnable`:**  
  The complete runnable logic for the primary assistant.

---

## ð Real-World Use Case Recap

Imagine a customer of Swiss Airlines interacting with a virtual assistant:
- They ask about their flight details, and the **primary assistant** responds with information.
- When the customer wants to update their flight, the **primary assistant** delegates the request to the **Flight Booking Assistant**.
- If the customer decides to book a hotel or car rental, the respective specialized assistants take over, ensuring that each domain is handled by an expert.

This multi-agent architecture leads to:
- **More accurate and context-specific responses**
- **Increased user trust** because actions are confirmed by domain experts
- **Easier maintenance and scalability** since each assistant can be updated independently

---

## ð¯ Conclusion

By structuring your chatbot into **specialized assistants** with a **primary assistant** handling routing, you create a **scalable**, **modular**, and **efficient** system. This approach:
- **Isolates complex logic** into focused sub-graphs (or workflows).
- **Empowers each assistant** to handle domain-specific tasks more effectively.
- **Improves user experience** by ensuring that the right assistant handles the right task.

This design pattern, akin to a **supervisor system in multi-agent architectures**, is ideal for complex applications like travel booking, customer support, and any domain requiring specialized handling of diverse tasks.

# Another Response:
# âï¸ **Multi-Assistant Travel Booking System with LangChain and Pydantic**  

In this guide, we'll break down a **multi-assistant travel booking system** step by step, ensuring beginners can easily follow along. We'll build assistants to handle:  

- âï¸ **Flight Booking**  
- ð¨ **Hotel Booking**  
- ð **Car Rental**  
- ðï¸ **Excursions**  
- ð **Primary Assistant** (routes between all other assistants)  

Weâll use **LangChain**, **Pydantic**, and **Python** concepts. Each section includes:  
â **Detailed explanations**  
ð **Code examples**  
ð¡ **Line-by-line explanations**  

---

## ð **Why a Multi-Assistant System?**  
This system follows the **Supervisor Design Pattern**âone main assistant delegates tasks to specialized assistants, improving modularity, scalability, and error handling.  

---

## âï¸ **Step 1: Setting Up the Project**  

### ð **Install Required Libraries**  
```bash
pip install langchain langchain-anthropic langchain-community pydantic
```
- `langchain`: Framework for building LLM-powered applications.  
- `langchain-anthropic`: Anthropic language model integration.  
- `pydantic`: Data validation and parsing using Python type annotations.  

---

## ðï¸ **Step 2: Creating the Assistant Class**  

This class acts as a wrapper to run each assistantâs workflow.

### ð **Code Example: `Assistant` Class**  
```python
from langchain_core.runnables import Runnable, RunnableConfig

class Assistant:
    def __init__(self, runnable: Runnable):
        self.runnable = runnable  # Each assistant will have a runnable workflow

    def __call__(self, state, config: RunnableConfig):
        while True:
            result = self.runnable.invoke(state)  # Execute the assistant's workflow
            if not result.tool_calls and (not result.content or (isinstance(result.content, list) and not result.content[0].get("text"))):
                state["messages"].append(("user", "Respond with a real output."))
            else:
                break
        return {"messages": result}
```

### ð **Line-by-Line Explanation**  
- **`__init__`**: Takes a `Runnable` (workflow) and assigns it to the assistant.  
- **`__call__`**: Repeatedly runs the assistant until it returns a meaningful response.  
- **Error Handling**: If no valid response is generated, it prompts the assistant to try again.  

---

## ð ï¸ **Step 3: Implementing `CompleteOrEscalate` Tool**  

This tool allows specialized assistants to:  
1ï¸â£ Mark a task as complete.  
2ï¸â£ Escalate the task back to the **Primary Assistant** if more information is needed.  

### ð **Code Example: `CompleteOrEscalate` Tool**  
```python
from pydantic import BaseModel, Field

class CompleteOrEscalate(BaseModel):
    cancel: bool = True  # True if the assistant should stop the task
    reason: str          # Reason for completing or escalating

    class Config:
        json_schema_extra = {
            "example": {
                "cancel": True,
                "reason": "User changed their mind about the current task."
            }
        }
```

### ð **Explanation**  
- **`cancel`**: If `True`, the assistant stops its task.  
- **`reason`**: Explains why the task was stopped or escalated.  
- **`json_schema_extra`**: Provides examples for documentation and testing.  

---

## âï¸ **Step 4: Flight Booking Assistant**  

Handles flight updates, confirmations, and cancellations.

### ð **Flight Booking Prompt**  
```python
from langchain_core.prompts import ChatPromptTemplate
from datetime import datetime

flight_booking_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a specialized assistant for handling flight updates. Confirm flight details, inform about fees, "
            "and escalate tasks if needed.\n\nCurrent user flight information:\n<Flights>\n{user_info}\n</Flights>"
            "\nCurrent time: {time}."
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

### ð **Explanation**  
- **Prompt**: Instructs the assistant to confirm flight details, handle updates, and escalate if needed.  
- **`partial(time=datetime.now)`**: Inserts the current time dynamically into the prompt.  

### ð **Combining Prompt with Tools**  
```python
update_flight_tools = [search_flights, update_ticket_to_new_flight, cancel_ticket, CompleteOrEscalate]
update_flight_runnable = flight_booking_prompt | llm.bind_tools(update_flight_tools)
```

### ð¡ **Key Concept**:  
- **`|` Operator**: Combines the prompt with the specified tools (pipeline operator).  
- **`bind_tools()`**: Connects relevant tools to the assistant, enabling them to perform actions like searching or canceling flights.  

---

## ð¨ **Step 5: Hotel Booking Assistant**  

Handles hotel searches, bookings, updates, and cancellations.

### ð **Hotel Booking Prompt**  
```python
book_hotel_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a hotel booking assistant. Search for hotels based on user preferences and confirm bookings. "
            "Escalate if user changes their mind or if additional information is required.\n\nCurrent time: {time}."
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)
```

### ð **Combining Prompt with Tools**  
```python
book_hotel_tools = [search_hotels, book_hotel, update_hotel, cancel_hotel, CompleteOrEscalate]
book_hotel_runnable = book_hotel_prompt | llm.bind_tools(book_hotel_tools)
```

---

## ð **Step 6: Car Rental Assistant**  

Handles car rental processes with similar logic.  

```python
book_car_rental_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are a car rental assistant. Find rental options based on user preferences and confirm details. "
            "Escalate to the main assistant if required.\n\nCurrent time: {time}."
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

book_car_rental_tools = [search_car_rentals, book_car_rental, update_car_rental, cancel_car_rental, CompleteOrEscalate]
book_car_rental_runnable = book_car_rental_prompt | llm.bind_tools(book_car_rental_tools)
```

---

## ðï¸ **Step 7: Excursion Assistant**  

```python
book_excursion_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are an excursion assistant. Suggest and book trips based on user interests. "
            "Escalate to the primary assistant if bookings canât be confirmed.\n\nCurrent time: {time}."
        ),
        ("placeholder", "{messages}"),
    ]
).partial(time=datetime.now)

book_excursion_tools = [search_trip_recommendations, book_excursion, update_excursion, cancel_excursion, CompleteOrEscalate]
book_excursion_runnable = book_excursion_prompt | llm.bind_tools(book_excursion_tools)
```

---

## ð **Step 8: Primary Assistant**  

The **Primary Assistant** routes tasks to the specialized assistants based on user requests.

### ð **Primary Assistant Prompt**  
```python
primary_assistant_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "You are the primary assistant for Swiss Airlines. Delegate tasks like flight updates, hotel bookings, "
            "car rentals, and excursions to specialized assistants. Escalate when appropriate."
        ),
        ("placeholder", "{messages}"),
    ]
)
```

### ð **Combining with Specialized Assistants**  
```python
primary_assistant_runnable = primary_assistant_prompt | llm.bind_tools(
    [ToFlightBookingAssistant, ToBookCarRental, ToHotelBookingAssistant, ToBookExcursion]
)
```

---

## ð¬ **Step 9: Running the Full Workflow**  

### ð **Run the Primary Assistant**  
```python
state = {"messages": [("user", "I want to book a flight from Zurich to Paris next Monday.")]}
primary_assistant = Assistant(primary_assistant_runnable)
result = primary_assistant(state, RunnableConfig())
print(result)
```

---

## ð **Congratulations!** ð  
You now have a fully functional **multi-assistant travel booking system** that:  
â Handles complex tasks with specialized assistants  
â Uses **LangChain** pipelines efficiently  
â Applies **Pydantic** for robust data validation  
â Escalates tasks when necessary via a **Primary Assistant**  

ð¬ **Got any questions?** Let me know! ð